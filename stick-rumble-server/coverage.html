
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>game: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mtomcal/stick-rumble-server/internal/game/gameserver.go (89.9%)</option>
				
				<option value="file1">github.com/mtomcal/stick-rumble-server/internal/game/match.go (92.8%)</option>
				
				<option value="file2">github.com/mtomcal/stick-rumble-server/internal/game/physics.go (90.2%)</option>
				
				<option value="file3">github.com/mtomcal/stick-rumble-server/internal/game/player.go (97.4%)</option>
				
				<option value="file4">github.com/mtomcal/stick-rumble-server/internal/game/projectile.go (100.0%)</option>
				
				<option value="file5">github.com/mtomcal/stick-rumble-server/internal/game/room.go (93.4%)</option>
				
				<option value="file6">github.com/mtomcal/stick-rumble-server/internal/game/weapon.go (100.0%)</option>
				
				<option value="file7">github.com/mtomcal/stick-rumble-server/internal/game/world.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package game

import (
        "context"
        "log"
        "sync"
        "time"
)

// Shoot failure reasons
const (
        ShootFailedNoPlayer = "no_player"
        ShootFailedCooldown = "cooldown"
        ShootFailedEmpty    = "empty"
        ShootFailedReload   = "reloading"
)

// ShootResult contains the result of a shoot attempt
type ShootResult struct {
        Success    bool
        Reason     string
        Projectile *Projectile
}

// GameServer manages the game loop and physics simulation
type GameServer struct {
        world             *World
        physics           *Physics
        projectileManager *ProjectileManager
        weaponStates      map[string]*WeaponState
        weaponMu          sync.RWMutex
        tickRate          time.Duration
        updateRate        time.Duration // Rate at which to broadcast updates to clients

        // Broadcast function to send state updates to clients
        broadcastFunc func(playerStates []PlayerState)

        // Callback for when a player's reload completes
        onReloadComplete func(playerID string)

        // Callback for when a projectile hits a player
        onHit func(hit HitEvent)

        // Callback for when a player respawns
        onRespawn func(playerID string, position Vector2)

        // Callback for match timer updates
        onMatchTimer func(roomID string, remainingSeconds int)

        // Callback for checking time limit across all rooms
        onCheckTimeLimit func()

        running bool
        mu      sync.RWMutex
        wg      sync.WaitGroup
}

// NewGameServer creates a new game server
func NewGameServer(broadcastFunc func(playerStates []PlayerState)) *GameServer <span class="cov8" title="1">{
        return &amp;GameServer{
                world:             NewWorld(),
                physics:           NewPhysics(),
                projectileManager: NewProjectileManager(),
                weaponStates:      make(map[string]*WeaponState),
                tickRate:          time.Duration(ServerTickInterval) * time.Millisecond,
                updateRate:        time.Duration(ClientUpdateInterval) * time.Millisecond,
                broadcastFunc:     broadcastFunc,
                running:           false,
        }
}</span>

// Start begins the game loop
func (gs *GameServer) Start(ctx context.Context) <span class="cov8" title="1">{
        gs.mu.Lock()
        if gs.running </span><span class="cov0" title="0">{
                gs.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">gs.running = true
        gs.mu.Unlock()

        gs.wg.Add(2)
        go gs.tickLoop(ctx)
        go gs.broadcastLoop(ctx)</span>
}

// Stop gracefully stops the game server
func (gs *GameServer) Stop() <span class="cov8" title="1">{
        gs.mu.Lock()
        gs.running = false
        gs.mu.Unlock()

        gs.wg.Wait()
}</span>

// tickLoop runs the physics simulation at ServerTickRate (60Hz)
func (gs *GameServer) tickLoop(ctx context.Context) <span class="cov8" title="1">{
        defer gs.wg.Done()

        ticker := time.NewTicker(gs.tickRate)
        defer ticker.Stop()

        lastTick := time.Now()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("Game tick loop stopped")
                        return</span>
                case now := &lt;-ticker.C:<span class="cov8" title="1">
                        // Calculate delta time in seconds
                        deltaTime := now.Sub(lastTick).Seconds()
                        lastTick = now

                        // Update all players
                        gs.updateAllPlayers(deltaTime)

                        // Update all projectiles
                        gs.projectileManager.Update(deltaTime)

                        // Check for projectile-player collisions (hit detection)
                        gs.checkHitDetection()

                        // Check for reload completions
                        gs.checkReloads()

                        // Check for respawns
                        gs.checkRespawns()

                        // Update invulnerability status
                        gs.updateInvulnerability()

                        // Update health regeneration
                        gs.updateHealthRegeneration(deltaTime)</span>
                }
        }
}

// broadcastLoop sends state updates to clients at ClientUpdateRate (20Hz)
func (gs *GameServer) broadcastLoop(ctx context.Context) <span class="cov8" title="1">{
        defer gs.wg.Done()

        ticker := time.NewTicker(gs.updateRate)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("Game broadcast loop stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        // Get all player states and broadcast
                        if gs.broadcastFunc != nil </span><span class="cov8" title="1">{
                                playerStates := gs.world.GetAllPlayers()
                                if len(playerStates) &gt; 0 </span><span class="cov8" title="1">{
                                        gs.broadcastFunc(playerStates)
                                }</span>
                        }
                }
        }
}

// updateAllPlayers updates physics for all players
func (gs *GameServer) updateAllPlayers(deltaTime float64) <span class="cov8" title="1">{
        // Get all players (this is thread-safe and returns pointers)
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Update each player's physics
        for _, player := range players </span><span class="cov8" title="1">{
                gs.physics.UpdatePlayer(player, deltaTime)
        }</span>
}

// AddPlayer adds a new player to the game world
func (gs *GameServer) AddPlayer(playerID string) *PlayerState <span class="cov8" title="1">{
        player := gs.world.AddPlayer(playerID)

        // Create weapon state for the player (everyone starts with a pistol)
        gs.weaponMu.Lock()
        gs.weaponStates[playerID] = NewWeaponState(NewPistol())
        gs.weaponMu.Unlock()

        return player
}</span>

// RemovePlayer removes a player from the game world
func (gs *GameServer) RemovePlayer(playerID string) <span class="cov8" title="1">{
        gs.world.RemovePlayer(playerID)

        // Remove weapon state
        gs.weaponMu.Lock()
        delete(gs.weaponStates, playerID)
        gs.weaponMu.Unlock()
}</span>

// UpdatePlayerInput updates a player's input state
func (gs *GameServer) UpdatePlayerInput(playerID string, input InputState) bool <span class="cov8" title="1">{
        return gs.world.UpdatePlayerInput(playerID, input)
}</span>

// GetPlayerState returns a snapshot of a player's state
func (gs *GameServer) GetPlayerState(playerID string) (PlayerState, bool) <span class="cov8" title="1">{
        player, exists := gs.world.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return PlayerState{}, false
        }</span>
        <span class="cov8" title="1">return player.Snapshot(), true</span>
}

// IsRunning returns whether the game server is currently running
func (gs *GameServer) IsRunning() bool <span class="cov8" title="1">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()
        return gs.running
}</span>

// GetWorld returns the game world
func (gs *GameServer) GetWorld() *World <span class="cov0" title="0">{
        return gs.world
}</span>

// SetOnReloadComplete sets the callback for when a player's reload completes
func (gs *GameServer) SetOnReloadComplete(callback func(playerID string)) <span class="cov8" title="1">{
        gs.onReloadComplete = callback
}</span>

// GetWeaponState returns the weapon state for a player
func (gs *GameServer) GetWeaponState(playerID string) *WeaponState <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        defer gs.weaponMu.RUnlock()
        return gs.weaponStates[playerID]
}</span>

// PlayerShoot attempts to fire a projectile for the given player
func (gs *GameServer) PlayerShoot(playerID string, aimAngle float64) ShootResult <span class="cov8" title="1">{
        // Check if player exists
        player, exists := gs.world.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedNoPlayer}
        }</span>

        // Get weapon state
        <span class="cov8" title="1">gs.weaponMu.RLock()
        ws := gs.weaponStates[playerID]
        gs.weaponMu.RUnlock()

        if ws == nil </span><span class="cov0" title="0">{
                return ShootResult{Success: false, Reason: ShootFailedNoPlayer}
        }</span>

        // Check if reloading
        <span class="cov8" title="1">if ws.IsReloading </span><span class="cov0" title="0">{
                return ShootResult{Success: false, Reason: ShootFailedReload}
        }</span>

        // Check if magazine is empty
        <span class="cov8" title="1">if ws.IsEmpty() </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedEmpty}
        }</span>

        // Check fire rate cooldown
        <span class="cov8" title="1">if !ws.CanShoot() </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedCooldown}
        }</span>

        // Create projectile at player position
        <span class="cov8" title="1">pos := player.GetPosition()
        proj := gs.projectileManager.CreateProjectile(
                playerID,
                pos,
                aimAngle,
                ws.Weapon.ProjectileSpeed,
        )

        // Record the shot (decrements ammo, sets cooldown)
        ws.RecordShot()

        return ShootResult{
                Success:    true,
                Projectile: proj,
        }</span>
}

// PlayerReload starts the reload process for a player
func (gs *GameServer) PlayerReload(playerID string) bool <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        ws := gs.weaponStates[playerID]
        gs.weaponMu.RUnlock()

        if ws == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if magazine is already full
        <span class="cov8" title="1">if ws.CurrentAmmo &gt;= ws.Weapon.MagazineSize </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">ws.StartReload()
        return ws.IsReloading</span>
}

// checkReloads checks all players for completed reloads
func (gs *GameServer) checkReloads() <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        defer gs.weaponMu.RUnlock()

        for playerID, ws := range gs.weaponStates </span><span class="cov8" title="1">{
                if ws.CheckReloadComplete() </span><span class="cov8" title="1">{
                        // Reload just completed - notify via callback
                        if gs.onReloadComplete != nil </span><span class="cov8" title="1">{
                                gs.onReloadComplete(playerID)
                        }</span>
                }
        }
}

// GetActiveProjectiles returns snapshots of all active projectiles
func (gs *GameServer) GetActiveProjectiles() []ProjectileSnapshot <span class="cov8" title="1">{
        return gs.projectileManager.GetProjectileSnapshots()
}</span>

// SetOnHit sets the callback for when a projectile hits a player
func (gs *GameServer) SetOnHit(callback func(hit HitEvent)) <span class="cov8" title="1">{
        gs.onHit = callback
}</span>

// SetOnRespawn sets the callback for when a player respawns
func (gs *GameServer) SetOnRespawn(callback func(playerID string, position Vector2)) <span class="cov0" title="0">{
        gs.onRespawn = callback
}</span>

// MarkPlayerDead marks a player as dead
func (gs *GameServer) MarkPlayerDead(playerID string) <span class="cov0" title="0">{
        player, exists := gs.world.GetPlayer(playerID)
        if exists </span><span class="cov0" title="0">{
                player.MarkDead()
        }</span>
}

// DamagePlayer applies damage to a player (for testing purposes)
func (gs *GameServer) DamagePlayer(playerID string, damage int) <span class="cov0" title="0">{
        player, exists := gs.world.GetPlayer(playerID)
        if exists </span><span class="cov0" title="0">{
                player.TakeDamage(damage)
        }</span>
}

// checkHitDetection checks for projectile-player collisions and processes hits
func (gs *GameServer) checkHitDetection() <span class="cov8" title="1">{
        // Get all active projectiles
        projectiles := gs.projectileManager.GetActiveProjectiles()
        if len(projectiles) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Get all players
        <span class="cov8" title="1">gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        if len(players) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for collisions
        <span class="cov8" title="1">hits := gs.physics.CheckAllProjectileCollisions(projectiles, players)

        // Process each hit
        for _, hit := range hits </span><span class="cov8" title="1">{
                // Get the attacker's weapon to determine damage
                gs.weaponMu.RLock()
                weaponState := gs.weaponStates[hit.AttackerID]
                gs.weaponMu.RUnlock()

                if weaponState == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">damage := weaponState.Weapon.Damage

                // Apply damage to victim
                victim, exists := gs.world.GetPlayer(hit.VictimID)
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">victim.TakeDamage(damage)

                // Deactivate the projectile
                gs.projectileManager.RemoveProjectile(hit.ProjectileID)

                // Notify via callback
                if gs.onHit != nil </span><span class="cov8" title="1">{
                        gs.onHit(hit)
                }</span>
        }
}

// checkRespawns checks all dead players and respawns them if ready
func (gs *GameServer) checkRespawns() <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Check each player for respawn
        for _, player := range players </span><span class="cov8" title="1">{
                if player.IsDead() &amp;&amp; player.CanRespawn() </span><span class="cov8" title="1">{
                        // Get balanced spawn point
                        spawnPos := gs.world.GetBalancedSpawnPoint(player.ID)

                        // Respawn the player
                        player.Respawn(spawnPos)

                        // Reset weapon state to default pistol (AC: "respawn with default pistol")
                        gs.mu.Lock()
                        gs.weaponStates[player.ID] = NewWeaponState(NewPistol())
                        gs.mu.Unlock()

                        // Notify via callback
                        if gs.onRespawn != nil </span><span class="cov0" title="0">{
                                gs.onRespawn(player.ID, spawnPos)
                        }</span>
                }
        }
}

// updateInvulnerability updates invulnerability status for all players
func (gs *GameServer) updateInvulnerability() <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Update each player's invulnerability
        for _, player := range players </span><span class="cov8" title="1">{
                player.UpdateInvulnerability()
        }</span>
}

// updateHealthRegeneration applies health regeneration to all players
func (gs *GameServer) updateHealthRegeneration(deltaTime float64) <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        now := time.Now()

        // Update each player's regeneration
        for _, player := range players </span><span class="cov8" title="1">{
                // Update regeneration state
                player.UpdateRegenerationState(now)

                // Apply regeneration if applicable
                player.ApplyRegeneration(now, deltaTime)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package game

import (
        "sync"
        "time"
)

// MatchState represents the current state of a match
type MatchState string

const (
        MatchStateWaiting MatchState = "waiting" // Waiting for players
        MatchStateActive  MatchState = "active"  // Match in progress
        MatchStateEnded   MatchState = "ended"   // Match completed
)

// MatchConfig contains configuration for a match
type MatchConfig struct {
        KillTarget       int // Number of kills needed to win (e.g., 20)
        TimeLimitSeconds int // Time limit in seconds (e.g., 420 = 7 minutes)
}

// PlayerScore represents a player's final score in a match
type PlayerScore struct {
        PlayerID string `json:"playerId"`
        Kills    int    `json:"kills"`
        Deaths   int    `json:"deaths"`
        XP       int    `json:"xp"`
}

// Match represents a game match with win conditions and state tracking
type Match struct {
        Config      MatchConfig
        State       MatchState
        StartTime   time.Time
        EndReason   string         // "kill_target" or "time_limit"
        PlayerKills map[string]int // Maps player ID to kill count
        mu          sync.RWMutex
}

// NewMatch creates a new match with default configuration
func NewMatch() *Match <span class="cov8" title="1">{
        return &amp;Match{
                Config: MatchConfig{
                        KillTarget:       20,
                        TimeLimitSeconds: 420, // 7 minutes
                },
                State:       MatchStateWaiting,
                PlayerKills: make(map[string]int),
        }
}</span>

// SetTestMode configures the match for fast testing
// Reduces kill target to 2 and time limit to 10 seconds
func (m *Match) SetTestMode() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Config.KillTarget = 2
        m.Config.TimeLimitSeconds = 10
}</span>

// Start begins the match and records the start time
func (m *Match) Start() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Don't restart if already active
        if m.State == MatchStateActive </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.State = MatchStateActive
        m.StartTime = time.Now()</span>
}

// GetRemainingSeconds calculates the remaining time in the match
func (m *Match) GetRemainingSeconds() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // If match not started, return full time
        if m.StartTime.IsZero() </span><span class="cov8" title="1">{
                return m.Config.TimeLimitSeconds
        }</span>

        <span class="cov8" title="1">elapsed := int(time.Since(m.StartTime).Seconds())
        remaining := m.Config.TimeLimitSeconds - elapsed

        if remaining &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return remaining</span>
}

// AddKill increments the kill count for a player
func (m *Match) AddKill(playerID string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.PlayerKills[playerID]++
}</span>

// CheckKillTarget checks if any player has reached the kill target
func (m *Match) CheckKillTarget() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills &gt;= m.Config.KillTarget </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// CheckTimeLimit checks if the time limit has been reached
func (m *Match) CheckTimeLimit() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // If match not started, time limit not reached
        if m.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">elapsed := time.Since(m.StartTime).Seconds()
        return elapsed &gt;= float64(m.Config.TimeLimitSeconds)</span>
}

// EndMatch ends the match with the given reason
func (m *Match) EndMatch(reason string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Only end once
        if m.State == MatchStateEnded </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.State = MatchStateEnded
        m.EndReason = reason</span>
}

// IsEnded returns true if the match has ended
func (m *Match) IsEnded() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return m.State == MatchStateEnded
}</span>

// DetermineWinners analyzes PlayerKills and returns player IDs with the highest kill count
// Returns multiple IDs in case of a tie
func (m *Match) DetermineWinners() []string <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Handle empty match
        if len(m.PlayerKills) == 0 </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        // Find the maximum kill count
        <span class="cov8" title="1">maxKills := 0
        for _, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills &gt; maxKills </span><span class="cov8" title="1">{
                        maxKills = kills
                }</span>
        }

        // Collect all players with the maximum kill count
        <span class="cov8" title="1">winners := []string{}
        for playerID, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills == maxKills </span><span class="cov8" title="1">{
                        winners = append(winners, playerID)
                }</span>
        }

        <span class="cov8" title="1">return winners</span>
}

// GetFinalScores collects final scores for all players in the match
func (m *Match) GetFinalScores(world *World) []PlayerScore <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        scores := []PlayerScore{}

        // Get all players from the world
        world.mu.RLock()
        defer world.mu.RUnlock()

        for playerID := range m.PlayerKills </span><span class="cov8" title="1">{
                player, exists := world.players[playerID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create score entry with player stats
                <span class="cov8" title="1">score := PlayerScore{
                        PlayerID: playerID,
                        Kills:    player.Kills,
                        Deaths:   player.Deaths,
                        XP:       player.XP,
                }
                scores = append(scores, score)</span>
        }

        <span class="cov8" title="1">return scores</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package game

import (
        "log"
        "math"
)

// Physics handles game physics calculations
type Physics struct{}

// NewPhysics creates a new physics engine
func NewPhysics() *Physics <span class="cov8" title="1">{
        return &amp;Physics{}
}</span>

// UpdatePlayer updates a player's physics state based on input and delta time
// deltaTime is in seconds
func (p *Physics) UpdatePlayer(player *PlayerState, deltaTime float64) <span class="cov8" title="1">{
        input := player.GetInput()
        currentVel := player.GetVelocity()

        // Calculate input direction vector
        inputDir := Vector2{X: 0, Y: 0}

        if input.Left </span><span class="cov8" title="1">{
                inputDir.X -= 1
        }</span>
        <span class="cov8" title="1">if input.Right </span><span class="cov8" title="1">{
                inputDir.X += 1
        }</span>
        <span class="cov8" title="1">if input.Up </span><span class="cov8" title="1">{
                inputDir.Y -= 1
        }</span>
        <span class="cov8" title="1">if input.Down </span><span class="cov8" title="1">{
                inputDir.Y += 1
        }</span>

        // Normalize input direction for diagonal movement
        <span class="cov8" title="1">inputDir = normalize(inputDir)

        // Apply acceleration or deceleration
        var newVel Vector2
        if inputDir.X != 0 || inputDir.Y != 0 </span><span class="cov8" title="1">{
                // Player is giving input - accelerate toward target velocity
                targetVel := Vector2{
                        X: inputDir.X * MovementSpeed,
                        Y: inputDir.Y * MovementSpeed,
                }

                newVel = accelerateToward(currentVel, targetVel, Acceleration, deltaTime)
        }</span> else<span class="cov8" title="1"> {
                // No input - decelerate to zero
                newVel = decelerateToZero(currentVel, Deceleration, deltaTime)
        }</span>

        // Sanitize velocity before setting it
        <span class="cov8" title="1">newVel = sanitizeVector2(newVel, "UpdatePlayer velocity")
        player.SetVelocity(newVel)

        // Update position based on velocity
        currentPos := player.GetPosition()
        newPos := Vector2{
                X: currentPos.X + newVel.X*deltaTime,
                Y: currentPos.Y + newVel.Y*deltaTime,
        }

        // Clamp position to arena bounds
        newPos = clampToArena(newPos)

        // Sanitize position before setting it
        newPos = sanitizeVector2(newPos, "UpdatePlayer position")
        player.SetPosition(newPos)</span>
}

// normalize returns a normalized vector (length = 1) or zero vector if input is zero
func normalize(v Vector2) Vector2 <span class="cov8" title="1">{
        length := math.Sqrt(v.X*v.X + v.Y*v.Y)
        if length == 0 </span><span class="cov8" title="1">{
                return Vector2{X: 0, Y: 0}
        }</span>
        <span class="cov8" title="1">return Vector2{
                X: v.X / length,
                Y: v.Y / length,
        }</span>
}

// accelerateToward smoothly accelerates current velocity toward target velocity
func accelerateToward(current, target Vector2, accel, deltaTime float64) Vector2 <span class="cov8" title="1">{
        diff := Vector2{
                X: target.X - current.X,
                Y: target.Y - current.Y,
        }

        // Calculate the maximum change possible this frame
        maxChange := accel * deltaTime

        // If we're close enough, just snap to target
        diffLength := math.Sqrt(diff.X*diff.X + diff.Y*diff.Y)
        if diffLength &lt;= maxChange </span><span class="cov8" title="1">{
                return target
        }</span>

        // Otherwise, move toward target by maxChange amount
        <span class="cov8" title="1">diffNorm := Vector2{
                X: diff.X / diffLength,
                Y: diff.Y / diffLength,
        }

        return Vector2{
                X: current.X + diffNorm.X*maxChange,
                Y: current.Y + diffNorm.Y*maxChange,
        }</span>
}

// decelerateToZero smoothly decelerates velocity to zero
func decelerateToZero(current Vector2, decel, deltaTime float64) Vector2 <span class="cov8" title="1">{
        return accelerateToward(current, Vector2{X: 0, Y: 0}, decel, deltaTime)
}</span>

// clampToArena ensures position stays within arena bounds
func clampToArena(pos Vector2) Vector2 <span class="cov8" title="1">{
        // Clamp to arena boundaries (accounting for player size)
        halfWidth := PlayerWidth / 2
        halfHeight := PlayerHeight / 2

        x := math.Max(halfWidth, math.Min(pos.X, ArenaWidth-halfWidth))
        y := math.Max(halfHeight, math.Min(pos.Y, ArenaHeight-halfHeight))

        return Vector2{X: x, Y: y}
}</span>

// HitEvent represents a successful projectile hit
type HitEvent struct {
        ProjectileID string
        VictimID     string
        AttackerID   string
}

// calculateDistance returns the Euclidean distance between two positions
func calculateDistance(pos1, pos2 Vector2) float64 <span class="cov8" title="1">{
        dx := pos2.X - pos1.X
        dy := pos2.Y - pos1.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>

// sanitizeVector2 ensures a Vector2 contains no NaN or Inf values
// If NaN or Inf is detected, it's replaced with 0 and logged as an error
func sanitizeVector2(v Vector2, context string) Vector2 <span class="cov8" title="1">{
        result := v
        sanitized := false

        if math.IsNaN(v.X) || math.IsInf(v.X, 0) </span><span class="cov0" title="0">{
                log.Printf("ERROR: %s contains invalid X value: %v, replacing with 0", context, v.X)
                result.X = 0
                sanitized = true
        }</span>
        <span class="cov8" title="1">if math.IsNaN(v.Y) || math.IsInf(v.Y, 0) </span><span class="cov0" title="0">{
                log.Printf("ERROR: %s contains invalid Y value: %v, replacing with 0", context, v.Y)
                result.Y = 0
                sanitized = true
        }</span>

        <span class="cov8" title="1">if sanitized </span><span class="cov0" title="0">{
                log.Printf("WARNING: %s sanitized from %+v to %+v", context, v, result)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// CheckProjectilePlayerCollision checks if a projectile intersects a player's hitbox using AABB
// Hitbox is 32x64 pixels (PlayerWidth x PlayerHeight) centered on player position
// Returns true if collision detected
func (p *Physics) CheckProjectilePlayerCollision(proj *Projectile, player *PlayerState) bool <span class="cov8" title="1">{
        // Don't check collision with dead players
        if !player.IsAlive() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't check collision with invulnerable players (spawn protection)
        <span class="cov8" title="1">if player.IsInvulnerable </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't check collision with owner
        <span class="cov8" title="1">if proj.OwnerID == player.ID </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">playerPos := player.GetPosition()

        // Validate range: reject hits beyond max projectile range
        // This prevents impossible long-range hits
        distanceTraveled := calculateDistance(proj.SpawnPosition, proj.Position)
        if distanceTraveled &gt; ProjectileMaxRange </span><span class="cov8" title="1">{
                return false
        }</span>

        // Calculate half-sizes for AABB collision
        <span class="cov8" title="1">halfWidth := PlayerWidth / 2
        halfHeight := PlayerHeight / 2

        // AABB collision detection
        // Check if projectile point is within the player's bounding box
        if math.Abs(proj.Position.X-playerPos.X) &lt; halfWidth &amp;&amp;
                math.Abs(proj.Position.Y-playerPos.Y) &lt; halfHeight </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// CheckAllProjectileCollisions checks all projectiles against all players
// Returns a slice of HitEvents for all detected collisions
func (p *Physics) CheckAllProjectileCollisions(projectiles []*Projectile, players []*PlayerState) []HitEvent <span class="cov8" title="1">{
        hits := make([]HitEvent, 0)

        for _, proj := range projectiles </span><span class="cov8" title="1">{
                if !proj.Active </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, player := range players </span><span class="cov8" title="1">{
                        if p.CheckProjectilePlayerCollision(proj, player) </span><span class="cov8" title="1">{
                                hits = append(hits, HitEvent{
                                        ProjectileID: proj.ID,
                                        VictimID:     player.ID,
                                        AttackerID:   proj.OwnerID,
                                })
                                break</span> // Each projectile can only hit one player
                        }
                }
        }

        <span class="cov8" title="1">return hits</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package game

import (
        "sync"
        "time"
)

// Vector2 represents a 2D vector for position and velocity
type Vector2 struct {
        X float64 `json:"x"`
        Y float64 `json:"y"`
}

// InputState represents the player's current input (WASD keys and aim)
type InputState struct {
        Up       bool    `json:"up"`       // W key
        Down     bool    `json:"down"`     // S key
        Left     bool    `json:"left"`     // A key
        Right    bool    `json:"right"`    // D key
        AimAngle float64 `json:"aimAngle"` // Aim angle in radians
}

// PlayerState represents a player's physics state in the game world
type PlayerState struct {
        ID                     string     `json:"id"`
        Position               Vector2    `json:"position"`
        Velocity               Vector2    `json:"velocity"`
        AimAngle               float64    `json:"aimAngle"`            // Aim angle in radians
        Health                 int        `json:"health"`              // Current health (0-100)
        IsInvulnerable         bool       `json:"isInvulnerable"`      // Spawn protection flag
        InvulnerabilityEndTime time.Time  `json:"invulnerabilityEnd"`  // When spawn protection ends
        DeathTime              *time.Time `json:"deathTime,omitempty"` // When player died (nil if alive)
        Kills                  int        `json:"kills"`               // Number of kills
        Deaths                 int        `json:"deaths"`              // Number of deaths
        XP                     int        `json:"xp"`                  // Experience points
        IsRegeneratingHealth   bool       `json:"isRegenerating"`      // Whether health is currently regenerating
        lastDamageTime         time.Time  // Private field: when player last took damage
        input                  InputState // Private field, accessed via methods
        mu                     sync.RWMutex
}

// NewPlayerState creates a new player state with default spawn position
func NewPlayerState(id string) *PlayerState <span class="cov8" title="1">{
        return &amp;PlayerState{
                ID: id,
                Position: Vector2{
                        X: ArenaWidth / 2,
                        Y: ArenaHeight / 2,
                },
                Velocity: Vector2{X: 0, Y: 0},
                Health:   PlayerMaxHealth,
                input:    InputState{},
        }
}</span>

// SetInput updates the player's input state (thread-safe)
func (p *PlayerState) SetInput(input InputState) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.input = input
}</span>

// GetInput retrieves the player's input state (thread-safe)
func (p *PlayerState) GetInput() InputState <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.input
}</span>

// SetPosition updates the player's position (thread-safe)
func (p *PlayerState) SetPosition(pos Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Position = pos
}</span>

// GetPosition retrieves the player's position (thread-safe)
func (p *PlayerState) GetPosition() Vector2 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Position
}</span>

// SetVelocity updates the player's velocity (thread-safe)
func (p *PlayerState) SetVelocity(vel Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Velocity = vel
}</span>

// GetVelocity retrieves the player's velocity (thread-safe)
func (p *PlayerState) GetVelocity() Vector2 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Velocity
}</span>

// SetAimAngle updates the player's aim angle (thread-safe)
func (p *PlayerState) SetAimAngle(angle float64) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.AimAngle = angle
}</span>

// GetAimAngle retrieves the player's aim angle (thread-safe)
func (p *PlayerState) GetAimAngle() float64 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.AimAngle
}</span>

// TakeDamage reduces the player's health by the given amount (thread-safe)
// Health will not go below 0
// Updates lastDamageTime to reset regeneration timer
func (p *PlayerState) TakeDamage(amount int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Health -= amount
        if p.Health &lt; 0 </span><span class="cov8" title="1">{
                p.Health = 0
        }</span>
        <span class="cov8" title="1">p.lastDamageTime = time.Now()
        p.IsRegeneratingHealth = false</span> // Stop regeneration when taking damage
}

// IsAlive returns true if the player has health remaining (thread-safe)
func (p *PlayerState) IsAlive() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Health &gt; 0
}</span>

// Snapshot returns a thread-safe copy of the player's current state
func (p *PlayerState) Snapshot() PlayerState <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return PlayerState{
                ID:                     p.ID,
                Position:               p.Position,
                Velocity:               p.Velocity,
                AimAngle:               p.AimAngle,
                Health:                 p.Health,
                IsInvulnerable:         p.IsInvulnerable,
                InvulnerabilityEndTime: p.InvulnerabilityEndTime,
                DeathTime:              p.DeathTime,
                Kills:                  p.Kills,
                Deaths:                 p.Deaths,
                XP:                     p.XP,
                IsRegeneratingHealth:   p.IsRegeneratingHealth,
        }
}</span>

// MarkDead marks the player as dead and records the death time (thread-safe)
func (p *PlayerState) MarkDead() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        now := time.Now()
        p.DeathTime = &amp;now
        p.Health = 0
}</span>

// IsDead returns true if the player is currently dead (thread-safe)
func (p *PlayerState) IsDead() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.DeathTime != nil
}</span>

// CanRespawn returns true if the respawn delay has passed (thread-safe)
func (p *PlayerState) CanRespawn() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        if p.DeathTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return time.Since(*p.DeathTime).Seconds() &gt;= RespawnDelay</span>
}

// Respawn resets the player to alive state at the given position (thread-safe)
func (p *PlayerState) Respawn(spawnPos Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Health = PlayerMaxHealth
        p.Position = spawnPos
        p.Velocity = Vector2{X: 0, Y: 0}
        p.DeathTime = nil
        p.IsInvulnerable = true
        p.InvulnerabilityEndTime = time.Now().Add(time.Duration(SpawnInvulnerabilityDuration * float64(time.Second)))
}</span>

// UpdateInvulnerability checks and updates invulnerability status (thread-safe)
func (p *PlayerState) UpdateInvulnerability() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.IsInvulnerable &amp;&amp; time.Now().After(p.InvulnerabilityEndTime) </span><span class="cov8" title="1">{
                p.IsInvulnerable = false
        }</span>
}

// IncrementKills increments the player's kill count (thread-safe)
func (p *PlayerState) IncrementKills() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Kills++
}</span>

// IncrementDeaths increments the player's death count (thread-safe)
func (p *PlayerState) IncrementDeaths() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Deaths++
}</span>

// AddXP adds experience points to the player (thread-safe)
func (p *PlayerState) AddXP(amount int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.XP += amount
}</span>

// GetKDRatio calculates the kill/death ratio (thread-safe)
// Returns 0 if player has no kills or deaths
func (p *PlayerState) GetKDRatio() float64 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        if p.Deaths == 0 </span><span class="cov8" title="1">{
                return float64(p.Kills)
        }</span>
        <span class="cov8" title="1">return float64(p.Kills) / float64(p.Deaths)</span>
}

// GetLastDamageTime returns the time when the player last took damage (thread-safe)
func (p *PlayerState) GetLastDamageTime() time.Time <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.lastDamageTime
}</span>

// CanRegenerate checks if the player can regenerate health at the given time (thread-safe)
// Returns true if enough time has passed since last damage and health is below max
func (p *PlayerState) CanRegenerate(now time.Time) bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        // Cannot regenerate if dead
        if p.DeathTime != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Cannot regenerate if at full health
        <span class="cov8" title="1">if p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if enough time has passed since last damage
        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        return timeSinceLastDamage &gt;= HealthRegenerationDelay</span>
}

// ApplyRegeneration applies health regeneration for the given deltaTime (thread-safe)
// Only regenerates if conditions are met (delay passed, not at max health, not dead)
func (p *PlayerState) ApplyRegeneration(now time.Time, deltaTime float64) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if we can regenerate
        if p.DeathTime != nil || p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        if timeSinceLastDamage &lt; HealthRegenerationDelay </span><span class="cov0" title="0">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        // Apply regeneration (use float calculation then round to nearest int)
        // This ensures regeneration works at 60Hz tick rate (deltaTime â‰ˆ 0.0167s)
        <span class="cov8" title="1">regenAmount := int(HealthRegenerationRate*deltaTime + 0.5)
        if regenAmount &lt; 1 </span><span class="cov0" title="0">{
                regenAmount = 1 // Ensure at least 1 HP per tick when regenerating
        }</span>
        <span class="cov8" title="1">p.Health += regenAmount

        // Cap at max health
        if p.Health &gt; PlayerMaxHealth </span><span class="cov8" title="1">{
                p.Health = PlayerMaxHealth
        }</span>

        // Update regeneration state
        <span class="cov8" title="1">p.IsRegeneratingHealth = p.Health &lt; PlayerMaxHealth</span>
}

// UpdateRegenerationState updates the IsRegeneratingHealth flag based on current conditions (thread-safe)
func (p *PlayerState) UpdateRegenerationState(now time.Time) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Update regeneration state
        if p.DeathTime != nil || p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        p.IsRegeneratingHealth = timeSinceLastDamage &gt;= HealthRegenerationDelay</span>
}

// IsRegenerating returns whether the player is currently regenerating health (thread-safe)
func (p *PlayerState) IsRegenerating() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.IsRegeneratingHealth
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package game

import (
        "math"
        "sync"
        "time"

        "github.com/google/uuid"
)

// Projectile represents a bullet/projectile in the game world
type Projectile struct {
        ID            string    `json:"id"`
        OwnerID       string    `json:"ownerId"`
        Position      Vector2   `json:"position"`
        Velocity      Vector2   `json:"velocity"`
        SpawnPosition Vector2   `json:"-"` // Initial position for range validation
        CreatedAt     time.Time `json:"-"`
        Active        bool      `json:"-"`
}

// ProjectileSnapshot is the network-transmittable version of Projectile
type ProjectileSnapshot struct {
        ID       string  `json:"id"`
        OwnerID  string  `json:"ownerId"`
        Position Vector2 `json:"position"`
        Velocity Vector2 `json:"velocity"`
}

// NewProjectile creates a new projectile with calculated velocity from angle
func NewProjectile(ownerID string, startPos Vector2, aimAngle float64, speed float64) *Projectile <span class="cov8" title="1">{
        return &amp;Projectile{
                ID:            uuid.New().String(),
                OwnerID:       ownerID,
                Position:      startPos,
                SpawnPosition: startPos, // Store spawn position for range validation
                Velocity: Vector2{
                        X: math.Cos(aimAngle) * speed,
                        Y: math.Sin(aimAngle) * speed,
                },
                CreatedAt: time.Now(),
                Active:    true,
        }
}</span>

// Update moves the projectile based on velocity and delta time
func (p *Projectile) Update(deltaTime float64) <span class="cov8" title="1">{
        p.Position.X += p.Velocity.X * deltaTime
        p.Position.Y += p.Velocity.Y * deltaTime
}</span>

// IsExpired returns true if the projectile has exceeded its max lifetime
func (p *Projectile) IsExpired() bool <span class="cov8" title="1">{
        return time.Since(p.CreatedAt) &gt;= ProjectileMaxLifetime
}</span>

// IsOutOfBounds returns true if the projectile is outside the arena
func (p *Projectile) IsOutOfBounds() bool <span class="cov8" title="1">{
        return p.Position.X &lt; 0 || p.Position.X &gt; ArenaWidth ||
                p.Position.Y &lt; 0 || p.Position.Y &gt; ArenaHeight
}</span>

// Deactivate marks the projectile as inactive (for removal)
func (p *Projectile) Deactivate() <span class="cov8" title="1">{
        p.Active = false
}</span>

// Snapshot returns a copy of the projectile state for network transmission
func (p *Projectile) Snapshot() ProjectileSnapshot <span class="cov8" title="1">{
        return ProjectileSnapshot{
                ID:       p.ID,
                OwnerID:  p.OwnerID,
                Position: p.Position,
                Velocity: p.Velocity,
        }
}</span>

// ProjectileManager manages all active projectiles in the game
type ProjectileManager struct {
        projectiles map[string]*Projectile
        mu          sync.RWMutex
}

// NewProjectileManager creates a new projectile manager
func NewProjectileManager() *ProjectileManager <span class="cov8" title="1">{
        return &amp;ProjectileManager{
                projectiles: make(map[string]*Projectile),
        }
}</span>

// CreateProjectile creates and adds a new projectile
func (pm *ProjectileManager) CreateProjectile(ownerID string, startPos Vector2, aimAngle float64, speed float64) *Projectile <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        proj := NewProjectile(ownerID, startPos, aimAngle, speed)
        pm.projectiles[proj.ID] = proj
        return proj
}</span>

// Update updates all projectiles and removes inactive ones
func (pm *ProjectileManager) Update(deltaTime float64) <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        // Collect IDs to remove
        toRemove := make([]string, 0)

        for id, proj := range pm.projectiles </span><span class="cov8" title="1">{
                // Check if projectile should be removed
                if !proj.Active || proj.IsExpired() || proj.IsOutOfBounds() </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, id)
                        continue</span>
                }

                // Update position
                <span class="cov8" title="1">proj.Update(deltaTime)

                // Check bounds after update
                if proj.IsOutOfBounds() </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, id)
                }</span>
        }

        // Remove inactive projectiles
        <span class="cov8" title="1">for _, id := range toRemove </span><span class="cov8" title="1">{
                delete(pm.projectiles, id)
        }</span>
}

// GetActiveProjectiles returns a slice of all active projectiles
func (pm *ProjectileManager) GetActiveProjectiles() []*Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]*Projectile, 0, len(pm.projectiles))
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetProjectileByID returns a projectile by its ID, or nil if not found
func (pm *ProjectileManager) GetProjectileByID(id string) *Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        return pm.projectiles[id]
}</span>

// RemoveProjectile removes a projectile by its ID
func (pm *ProjectileManager) RemoveProjectile(id string) <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        delete(pm.projectiles, id)
}</span>

// GetProjectilesByOwner returns all projectiles owned by a specific player
func (pm *ProjectileManager) GetProjectilesByOwner(ownerID string) []*Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]*Projectile, 0)
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.OwnerID == ownerID &amp;&amp; proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetProjectileSnapshots returns snapshots of all active projectiles for network transmission
func (pm *ProjectileManager) GetProjectileSnapshots() []ProjectileSnapshot <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]ProjectileSnapshot, 0, len(pm.projectiles))
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj.Snapshot())
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package game

import (
        "encoding/json"
        "errors"
        "log"
        "os"
        "sync"
        "time"

        "github.com/google/uuid"
)

// Player represents a connected player
type Player struct {
        ID       string
        SendChan chan []byte
}

// Room represents a game room with multiple players
type Room struct {
        ID         string
        Players    []*Player
        MaxPlayers int
        Match      *Match // Match state tracking
        mu         sync.RWMutex
}

// NewRoom creates a new room with a unique ID
func NewRoom() *Room <span class="cov8" title="1">{
        match := NewMatch()

        // Enable test mode if TEST_MODE environment variable is set
        if os.Getenv("TEST_MODE") == "true" </span><span class="cov0" title="0">{
                match.SetTestMode()
                log.Println("Match created in TEST MODE (kill target: 2, time limit: 10s)")
        }</span>

        <span class="cov8" title="1">return &amp;Room{
                ID:         uuid.New().String(),
                Players:    make([]*Player, 0, 8),
                MaxPlayers: 8,
                Match:      match,
        }</span>
}

// AddPlayer adds a player to the room
func (r *Room) AddPlayer(player *Player) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if len(r.Players) &gt;= r.MaxPlayers </span><span class="cov8" title="1">{
                return errors.New("room is full")
        }</span>

        <span class="cov8" title="1">r.Players = append(r.Players, player)
        return nil</span>
}

// RemovePlayer removes a player from the room by ID
func (r *Room) RemovePlayer(playerID string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Remove player from slice
                        r.Players = append(r.Players[:i], r.Players[i+1:]...)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsEmpty returns true if the room has no players (thread-safe)
func (r *Room) IsEmpty() bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.Players) == 0
}</span>

// PlayerCount returns the number of players in the room (thread-safe)
func (r *Room) PlayerCount() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.Players)
}</span>

// Broadcast sends a message to all players in the room, optionally excluding a sender
func (r *Room) Broadcast(message []byte, excludePlayerID string) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        for _, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID != excludePlayerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                log.Printf("Warning: Could not send message to player %s (channel closed)", player.ID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- message:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov8" title="1">
                                        log.Printf("Warning: Could not send message to player %s (channel full)", player.ID)</span>
                                }
                        }()
                }
        }
}

// GetPlayer returns a player by ID, or nil if not found
func (r *Room) GetPlayer(playerID string) *Player <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        for _, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        return player
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RoomManager manages all game rooms and player assignments
type RoomManager struct {
        rooms          map[string]*Room
        waitingPlayers []*Player
        playerToRoom   map[string]string // Maps player ID to room ID
        mu             sync.RWMutex
}

// NewRoomManager creates a new room manager
func NewRoomManager() *RoomManager <span class="cov8" title="1">{
        return &amp;RoomManager{
                rooms:          make(map[string]*Room),
                waitingPlayers: make([]*Player, 0),
                playerToRoom:   make(map[string]string),
        }
}</span>

// AddPlayer adds a player and creates a room if we have 2 waiting players
func (rm *RoomManager) AddPlayer(player *Player) *Room <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Add to waiting list
        rm.waitingPlayers = append(rm.waitingPlayers, player)

        // If we have 2 players, create a room
        if len(rm.waitingPlayers) &gt;= 2 </span><span class="cov8" title="1">{
                // Create new room
                room := NewRoom()

                // Add both waiting players to the room
                player1 := rm.waitingPlayers[0]
                player2 := rm.waitingPlayers[1]

                room.AddPlayer(player1)
                room.AddPlayer(player2)

                // Clear waiting list
                rm.waitingPlayers = rm.waitingPlayers[2:]

                // Register room
                rm.rooms[room.ID] = room
                rm.playerToRoom[player1.ID] = room.ID
                rm.playerToRoom[player2.ID] = room.ID

                // Start the match
                room.Match.Start()

                // Log room creation
                log.Printf("Room created: %s with players: [%s, %s]", room.ID, player1.ID, player2.ID)

                // Send room:joined messages to both players
                rm.sendRoomJoinedMessage(player1, room)
                rm.sendRoomJoinedMessage(player2, room)

                return room
        }</span>

        // Not enough players yet
        <span class="cov8" title="1">return nil</span>
}

// sendRoomJoinedMessage sends a room:joined message to a player
func (rm *RoomManager) sendRoomJoinedMessage(player *Player, room *Room) <span class="cov8" title="1">{
        message := map[string]interface{}{
                "type":      "room:joined",
                "timestamp": time.Now().UnixMilli(),
                "data": map[string]interface{}{
                        "roomId":   room.ID,
                        "playerId": player.ID,
                },
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling room:joined message: %v", err)
                return
        }</span>

        // Use recover to handle closed channel panics gracefully
        <span class="cov8" title="1">func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Could not send room:joined message to player %s (channel closed)", player.ID)
                        }</span>
                }()

                <span class="cov8" title="1">select </span>{
                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                        // Message sent successfully
                default:<span class="cov0" title="0">
                        log.Printf("Warning: Could not send room:joined message to player %s (channel full)", player.ID)</span>
                }
        }()
}

// RemovePlayer removes a player from their room and notifies other players
func (rm *RoomManager) RemovePlayer(playerID string) <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Find and remove from waiting list if present
        for i, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        rm.waitingPlayers = append(rm.waitingPlayers[:i], rm.waitingPlayers[i+1:]...)
                        return
                }</span>
        }

        // Find player's room
        <span class="cov8" title="1">roomID, exists := rm.playerToRoom[playerID]
        if !exists </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">room, exists := rm.rooms[roomID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove player from room
        <span class="cov8" title="1">room.RemovePlayer(playerID)

        // Send player:left message to remaining players
        message := map[string]interface{}{
                "type":      "player:left",
                "timestamp": time.Now().UnixMilli(),
                "data": map[string]interface{}{
                        "playerId": playerID,
                },
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:left message: %v", err)
        }</span> else<span class="cov8" title="1"> {
                room.Broadcast(msgBytes, "")
        }</span>

        // Clean up player to room mapping
        <span class="cov8" title="1">delete(rm.playerToRoom, playerID)

        // If room is empty, remove it
        if room.IsEmpty() </span><span class="cov8" title="1">{
                delete(rm.rooms, roomID)
                log.Printf("Room %s removed (no players remaining)", roomID)
        }</span>
}

// GetRoomByPlayerID finds a room by player ID
func (rm *RoomManager) GetRoomByPlayerID(playerID string) *Room <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        roomID, exists := rm.playerToRoom[playerID]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return rm.rooms[roomID]</span>
}

// SendToWaitingPlayer sends a message to a waiting player (not in a room yet)
func (rm *RoomManager) SendToWaitingPlayer(playerID string, msgBytes []byte) <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                log.Printf("Warning: Could not send message to waiting player %s (channel closed)", playerID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov8" title="1">
                                        log.Printf("Warning: Could not send message to waiting player %s (channel full)", playerID)</span>
                                }
                        }()
                        <span class="cov8" title="1">return</span>
                }
        }
}

// SendToPlayer sends a message to any player (in room or waiting)
// Returns true if player was found and message was queued, false otherwise
func (rm *RoomManager) SendToPlayer(playerID string, msgBytes []byte) bool <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        // First, check if player is in a room
        roomID, inRoom := rm.playerToRoom[playerID]
        if inRoom </span><span class="cov8" title="1">{
                room, roomExists := rm.rooms[roomID]
                if roomExists </span><span class="cov8" title="1">{
                        player := room.GetPlayer(playerID)
                        if player != nil </span><span class="cov8" title="1">{
                                // Use recover to handle closed channel panics gracefully
                                func() </span><span class="cov8" title="1">{
                                        defer func() </span><span class="cov8" title="1">{
                                                if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                        log.Printf("Warning: Could not send message to player %s (channel closed)", playerID)
                                                }</span>
                                        }()

                                        <span class="cov8" title="1">select </span>{
                                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                                // Message sent successfully
                                        default:<span class="cov8" title="1">
                                                log.Printf("Warning: Could not send message to player %s (channel full)", playerID)</span>
                                        }
                                }()
                                <span class="cov8" title="1">return true</span>
                        }
                }
        }

        // Second, check waiting players
        <span class="cov8" title="1">for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                                log.Printf("Warning: Could not send message to waiting player %s (channel closed)", playerID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov0" title="0">
                                        log.Printf("Warning: Could not send message to waiting player %s (channel full)", playerID)</span>
                                }
                        }()
                        <span class="cov8" title="1">return true</span>
                }
        }

        // Player not found
        <span class="cov8" title="1">return false</span>
}

// BroadcastToAll sends a message to all players (in rooms and waiting)
func (rm *RoomManager) BroadcastToAll(msgBytes []byte) <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        // Broadcast to all rooms
        for _, room := range rm.rooms </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>

        // Send to all waiting players
        <span class="cov8" title="1">for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                // Use recover to handle closed channel panics gracefully
                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                        log.Printf("Warning: Could not send message to waiting player %s (channel closed)", player.ID)
                                }</span>
                        }()

                        <span class="cov8" title="1">select </span>{
                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                // Message sent successfully
                        default:<span class="cov8" title="1">
                                log.Printf("Warning: Could not send message to waiting player %s (channel full)", player.ID)</span>
                        }
                }()
        }
}

// GetAllRooms returns a snapshot of all active rooms (thread-safe)
func (rm *RoomManager) GetAllRooms() []*Room <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rooms := make([]*Room, 0, len(rm.rooms))
        for _, room := range rm.rooms </span><span class="cov8" title="1">{
                rooms = append(rooms, room)
        }</span>
        <span class="cov8" title="1">return rooms</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package game

import (
        "time"
)

// Weapon constants for Pistol (from Story 2.3 requirements)
const (
        // PistolDamage is the damage per shot (25 damage = 4 shots to kill at 100 health)
        PistolDamage = 25

        // PistolFireRate is rounds per second (3 rounds/sec = 333ms cooldown)
        PistolFireRate = 3.0

        // PistolMagazineSize is the number of rounds before reload required
        PistolMagazineSize = 15

        // PistolReloadTime is the time required to reload in milliseconds
        PistolReloadTime = 1500 * time.Millisecond

        // PistolProjectileSpeed is the projectile travel speed in pixels per second
        PistolProjectileSpeed = 800.0

        // ProjectileMaxLifetime is the maximum time a projectile exists (1 second)
        ProjectileMaxLifetime = 1 * time.Second

        // ProjectileMaxRange is the maximum range for hit detection (px)
        // Set to projectile speed * lifetime = 800px/s * 1s = 800px
        ProjectileMaxRange = 800.0
)

// Weapon defines a weapon type with its properties
type Weapon struct {
        Name            string
        Damage          int
        FireRate        float64       // Rounds per second
        MagazineSize    int           // Rounds per magazine
        ReloadTime      time.Duration // Time to reload
        ProjectileSpeed float64       // Projectile speed in px/s
}

// NewPistol creates a new Pistol weapon instance
func NewPistol() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:            "Pistol",
                Damage:          PistolDamage,
                FireRate:        PistolFireRate,
                MagazineSize:    PistolMagazineSize,
                ReloadTime:      PistolReloadTime,
                ProjectileSpeed: PistolProjectileSpeed,
        }
}</span>

// WeaponState tracks the current state of a player's weapon
type WeaponState struct {
        Weapon          *Weapon
        CurrentAmmo     int
        IsReloading     bool
        LastShotTime    time.Time
        ReloadStartTime time.Time
}

// NewWeaponState creates a new weapon state with full ammo
func NewWeaponState(weapon *Weapon) *WeaponState <span class="cov8" title="1">{
        return &amp;WeaponState{
                Weapon:      weapon,
                CurrentAmmo: weapon.MagazineSize,
                IsReloading: false,
        }
}</span>

// CanShoot returns true if the weapon can fire
func (ws *WeaponState) CanShoot() bool <span class="cov8" title="1">{
        // Cannot shoot while reloading
        if ws.IsReloading </span><span class="cov8" title="1">{
                return false
        }</span>

        // Cannot shoot with empty magazine
        <span class="cov8" title="1">if ws.CurrentAmmo &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check fire rate cooldown
        <span class="cov8" title="1">if !ws.LastShotTime.IsZero() </span><span class="cov8" title="1">{
                cooldown := time.Duration(float64(time.Second) / ws.Weapon.FireRate)
                if time.Since(ws.LastShotTime) &lt; cooldown </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// RecordShot records that a shot was fired, decrements ammo
func (ws *WeaponState) RecordShot() <span class="cov8" title="1">{
        if ws.CurrentAmmo &gt; 0 </span><span class="cov8" title="1">{
                ws.CurrentAmmo--
        }</span>
        <span class="cov8" title="1">ws.LastShotTime = time.Now()</span>
}

// StartReload begins the reload process
func (ws *WeaponState) StartReload() <span class="cov8" title="1">{
        // Don't reload if already reloading
        if ws.IsReloading </span><span class="cov8" title="1">{
                return
        }</span>

        // Don't reload if magazine is full
        <span class="cov8" title="1">if ws.CurrentAmmo &gt;= ws.Weapon.MagazineSize </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ws.IsReloading = true
        ws.ReloadStartTime = time.Now()</span>
}

// CheckReloadComplete checks if reload is done and refills ammo if so
// Returns true if reload just completed
func (ws *WeaponState) CheckReloadComplete() bool <span class="cov8" title="1">{
        if !ws.IsReloading </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if time.Since(ws.ReloadStartTime) &gt;= ws.Weapon.ReloadTime </span><span class="cov8" title="1">{
                ws.CurrentAmmo = ws.Weapon.MagazineSize
                ws.IsReloading = false
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// IsEmpty returns true if the magazine is empty
func (ws *WeaponState) IsEmpty() bool <span class="cov8" title="1">{
        return ws.CurrentAmmo &lt;= 0
}</span>

// GetAmmoInfo returns current and max ammo
func (ws *WeaponState) GetAmmoInfo() (current, max int) <span class="cov8" title="1">{
        return ws.CurrentAmmo, ws.Weapon.MagazineSize
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package game

import (
        "math"
        "math/rand"
        "sync"
)

// World manages the game state and all players
type World struct {
        players map[string]*PlayerState
        mu      sync.RWMutex
}

// NewWorld creates a new game world
func NewWorld() *World <span class="cov8" title="1">{
        return &amp;World{
                players: make(map[string]*PlayerState),
        }
}</span>

// AddPlayer adds a new player to the world
func (w *World) AddPlayer(playerID string) *PlayerState <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        player := NewPlayerState(playerID)
        w.players[playerID] = player
        return player
}</span>

// RemovePlayer removes a player from the world
func (w *World) RemovePlayer(playerID string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        delete(w.players, playerID)
}</span>

// GetPlayer retrieves a player by ID
func (w *World) GetPlayer(playerID string) (*PlayerState, bool) <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        player, exists := w.players[playerID]
        return player, exists
}</span>

// GetAllPlayers returns snapshots of all players (thread-safe)
func (w *World) GetAllPlayers() []PlayerState <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        snapshots := make([]PlayerState, 0, len(w.players))
        for _, player := range w.players </span><span class="cov8" title="1">{
                snapshots = append(snapshots, player.Snapshot())
        }</span>
        <span class="cov8" title="1">return snapshots</span>
}

// PlayerCount returns the number of players in the world
func (w *World) PlayerCount() int <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return len(w.players)
}</span>

// UpdatePlayerInput updates a player's input state
func (w *World) UpdatePlayerInput(playerID string, input InputState) bool <span class="cov8" title="1">{
        player, exists := w.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">player.SetInput(input)
        // Also update the player's aim angle for broadcasting
        player.SetAimAngle(input.AimAngle)
        return true</span>
}

// GetBalancedSpawnPoint finds a spawn point furthest from all living enemy players
// Returns the center position if no enemies are present
func (w *World) GetBalancedSpawnPoint(excludePlayerID string) Vector2 <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Collect positions of all living enemy players
        enemyPositions := make([]Vector2, 0)
        for id, player := range w.players </span><span class="cov8" title="1">{
                if id != excludePlayerID &amp;&amp; !player.IsDead() </span><span class="cov8" title="1">{
                        enemyPositions = append(enemyPositions, player.GetPosition())
                }</span>
        }

        // If no enemies, spawn at center
        <span class="cov8" title="1">if len(enemyPositions) == 0 </span><span class="cov8" title="1">{
                return Vector2{X: ArenaWidth / 2, Y: ArenaHeight / 2}
        }</span>

        // Try 10 random spawn candidates and pick the one furthest from enemies
        <span class="cov8" title="1">bestSpawn := Vector2{X: ArenaWidth / 2, Y: ArenaHeight / 2}
        bestMinDistance := 0.0

        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                // Generate random spawn point with margin from edges
                margin := 100.0
                candidate := Vector2{
                        X: margin + rand.Float64()*(ArenaWidth-2*margin),
                        Y: margin + rand.Float64()*(ArenaHeight-2*margin),
                }

                // Find minimum distance to any enemy
                minDistance := math.MaxFloat64
                for _, enemyPos := range enemyPositions </span><span class="cov8" title="1">{
                        dist := distance(candidate, enemyPos)
                        if dist &lt; minDistance </span><span class="cov8" title="1">{
                                minDistance = dist
                        }</span>
                }

                // Keep the spawn point with the largest minimum distance
                <span class="cov8" title="1">if minDistance &gt; bestMinDistance </span><span class="cov8" title="1">{
                        bestMinDistance = minDistance
                        bestSpawn = candidate
                }</span>
        }

        <span class="cov8" title="1">return bestSpawn</span>
}

// distance calculates the Euclidean distance between two points
func distance(a, b Vector2) float64 <span class="cov8" title="1">{
        dx := a.X - b.X
        dy := a.Y - b.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
