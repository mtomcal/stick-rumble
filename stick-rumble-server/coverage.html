
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>game: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mtomcal/stick-rumble-server/internal/game/clock.go (100.0%)</option>
				
				<option value="file1">github.com/mtomcal/stick-rumble-server/internal/game/gameserver.go (89.0%)</option>
				
				<option value="file2">github.com/mtomcal/stick-rumble-server/internal/game/match.go (92.8%)</option>
				
				<option value="file3">github.com/mtomcal/stick-rumble-server/internal/game/melee_attack.go (94.4%)</option>
				
				<option value="file4">github.com/mtomcal/stick-rumble-server/internal/game/physics.go (91.0%)</option>
				
				<option value="file5">github.com/mtomcal/stick-rumble-server/internal/game/player.go (100.0%)</option>
				
				<option value="file6">github.com/mtomcal/stick-rumble-server/internal/game/projectile.go (100.0%)</option>
				
				<option value="file7">github.com/mtomcal/stick-rumble-server/internal/game/room.go (90.4%)</option>
				
				<option value="file8">github.com/mtomcal/stick-rumble-server/internal/game/weapon.go (100.0%)</option>
				
				<option value="file9">github.com/mtomcal/stick-rumble-server/internal/game/weapon_crate.go (100.0%)</option>
				
				<option value="file10">github.com/mtomcal/stick-rumble-server/internal/game/weapon_factory.go (100.0%)</option>
				
				<option value="file11">github.com/mtomcal/stick-rumble-server/internal/game/world.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package game

import (
        "sync"
        "time"
)

// Clock provides time-related operations for game logic.
// This interface enables dependency injection for testing,
// allowing tests to use a manual clock that can be advanced
// instantly instead of waiting for real time to pass.
type Clock interface {
        // Now returns the current time.
        Now() time.Time

        // Since returns the time elapsed since t.
        // Equivalent to Now().Sub(t).
        Since(t time.Time) time.Duration
}

// RealClock implements Clock using the actual system time.
// This is the production implementation.
type RealClock struct{}

// Now returns the current system time.
func (rc *RealClock) Now() time.Time <span class="cov8" title="1">{
        return time.Now()
}</span>

// Since returns the time elapsed since t using system time.
func (rc *RealClock) Since(t time.Time) time.Duration <span class="cov8" title="1">{
        return time.Since(t)
}</span>

// ManualClock implements Clock with manually controllable time.
// This is used in tests to advance time instantly without waiting.
// ManualClock is thread-safe and can be used in concurrent tests.
type ManualClock struct {
        currentTime time.Time
        mu          sync.RWMutex
}

// NewManualClock creates a new ManualClock starting at the given time.
func NewManualClock(startTime time.Time) *ManualClock <span class="cov8" title="1">{
        return &amp;ManualClock{
                currentTime: startTime,
        }
}</span>

// Now returns the current manual time.
func (mc *ManualClock) Now() time.Time <span class="cov8" title="1">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()
        return mc.currentTime
}</span>

// Since returns the time elapsed since t based on the manual clock.
func (mc *ManualClock) Since(t time.Time) time.Duration <span class="cov8" title="1">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()
        return mc.currentTime.Sub(t)
}</span>

// Advance moves the manual clock forward (or backward) by the given duration.
// This method is thread-safe.
func (mc *ManualClock) Advance(d time.Duration) <span class="cov8" title="1">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        mc.currentTime = mc.currentTime.Add(d)
}</span>

// SetTime sets the manual clock to a specific time.
// This method is thread-safe.
func (mc *ManualClock) SetTime(t time.Time) <span class="cov8" title="1">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        mc.currentTime = t
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package game

import (
        "context"
        "log"
        "sync"
        "time"
)

// Shoot failure reasons
const (
        ShootFailedNoPlayer = "no_player"
        ShootFailedCooldown = "cooldown"
        ShootFailedEmpty    = "empty"
        ShootFailedReload   = "reloading"
)

// ShootResult contains the result of a shoot attempt
type ShootResult struct {
        Success    bool
        Reason     string
        Projectile *Projectile
}

// GameServer manages the game loop and physics simulation
type GameServer struct {
        world              *World
        physics            *Physics
        projectileManager  *ProjectileManager
        weaponCrateManager *WeaponCrateManager
        weaponStates       map[string]*WeaponState
        weaponMu           sync.RWMutex
        tickRate           time.Duration
        updateRate         time.Duration // Rate at which to broadcast updates to clients
        clock              Clock         // Clock for time operations (injectable for testing)

        // Broadcast function to send state updates to clients
        broadcastFunc func(playerStates []PlayerState)

        // Callback for when a player's reload completes
        onReloadComplete func(playerID string)

        // Callback for when a projectile hits a player
        onHit func(hit HitEvent)

        // Callback for when a player respawns
        onRespawn func(playerID string, position Vector2)

        // Callback for match timer updates
        onMatchTimer func(roomID string, remainingSeconds int)

        // Callback for checking time limit across all rooms
        onCheckTimeLimit func()

        // Callback for when a weapon is picked up
        onWeaponPickup func(playerID, crateID, weaponType string, respawnTime time.Time)

        // Callback for when a weapon crate respawns
        onWeaponRespawn func(crate *WeaponCrate)

        running bool
        mu      sync.RWMutex
        wg      sync.WaitGroup
}

// NewGameServer creates a new game server with a real clock
func NewGameServer(broadcastFunc func(playerStates []PlayerState)) *GameServer <span class="cov8" title="1">{
        return NewGameServerWithClock(broadcastFunc, &amp;RealClock{})
}</span>

// NewGameServerWithClock creates a new game server with a custom clock (for testing)
func NewGameServerWithClock(broadcastFunc func(playerStates []PlayerState), clock Clock) *GameServer <span class="cov8" title="1">{
        return &amp;GameServer{
                world:              NewWorldWithClock(clock),
                physics:            NewPhysics(),
                projectileManager:  NewProjectileManager(),
                weaponCrateManager: NewWeaponCrateManager(),
                weaponStates:       make(map[string]*WeaponState),
                tickRate:           time.Duration(ServerTickInterval) * time.Millisecond,
                updateRate:         time.Duration(ClientUpdateInterval) * time.Millisecond,
                broadcastFunc:      broadcastFunc,
                clock:              clock,
                running:            false,
        }
}</span>

// Start begins the game loop
func (gs *GameServer) Start(ctx context.Context) <span class="cov8" title="1">{
        gs.mu.Lock()
        if gs.running </span><span class="cov0" title="0">{
                gs.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">gs.running = true
        gs.mu.Unlock()

        gs.wg.Add(2)
        go gs.tickLoop(ctx)
        go gs.broadcastLoop(ctx)</span>
}

// Stop gracefully stops the game server
func (gs *GameServer) Stop() <span class="cov8" title="1">{
        gs.mu.Lock()
        gs.running = false
        gs.mu.Unlock()

        gs.wg.Wait()
}</span>

// tickLoop runs the physics simulation at ServerTickRate (60Hz)
func (gs *GameServer) tickLoop(ctx context.Context) <span class="cov8" title="1">{
        defer gs.wg.Done()

        ticker := time.NewTicker(gs.tickRate)
        defer ticker.Stop()

        lastTick := gs.clock.Now()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("Game tick loop stopped")
                        return</span>
                case now := &lt;-ticker.C:<span class="cov8" title="1">
                        // Calculate delta time in seconds
                        deltaTime := now.Sub(lastTick).Seconds()
                        lastTick = now

                        // Update all players
                        gs.updateAllPlayers(deltaTime)

                        // Update all projectiles
                        gs.projectileManager.Update(deltaTime)

                        // Check for projectile-player collisions (hit detection)
                        gs.checkHitDetection()

                        // Check for reload completions
                        gs.checkReloads()

                        // Check for respawns
                        gs.checkRespawns()

                        // Update invulnerability status
                        gs.updateInvulnerability()

                        // Update health regeneration
                        gs.updateHealthRegeneration(deltaTime)

                        // Check for weapon respawns
                        gs.checkWeaponRespawns()</span>
                }
        }
}

// broadcastLoop sends state updates to clients at ClientUpdateRate (20Hz)
func (gs *GameServer) broadcastLoop(ctx context.Context) <span class="cov8" title="1">{
        defer gs.wg.Done()

        ticker := time.NewTicker(gs.updateRate)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("Game broadcast loop stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        // Get all player states and broadcast
                        if gs.broadcastFunc != nil </span><span class="cov8" title="1">{
                                playerStates := gs.world.GetAllPlayers()
                                if len(playerStates) &gt; 0 </span><span class="cov8" title="1">{
                                        gs.broadcastFunc(playerStates)
                                }</span>
                        }
                }
        }
}

// updateAllPlayers updates physics for all players
func (gs *GameServer) updateAllPlayers(deltaTime float64) <span class="cov8" title="1">{
        // Get all players (this is thread-safe and returns pointers)
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Update each player's physics
        for _, player := range players </span><span class="cov8" title="1">{
                gs.physics.UpdatePlayer(player, deltaTime)
        }</span>
}

// AddPlayer adds a new player to the game world
func (gs *GameServer) AddPlayer(playerID string) *PlayerState <span class="cov8" title="1">{
        player := gs.world.AddPlayer(playerID)

        // Create weapon state for the player (everyone starts with a pistol)
        gs.weaponMu.Lock()
        gs.weaponStates[playerID] = NewWeaponStateWithClock(NewPistol(), gs.clock)
        gs.weaponMu.Unlock()

        return player
}</span>

// RemovePlayer removes a player from the game world
func (gs *GameServer) RemovePlayer(playerID string) <span class="cov8" title="1">{
        gs.world.RemovePlayer(playerID)

        // Remove weapon state
        gs.weaponMu.Lock()
        delete(gs.weaponStates, playerID)
        gs.weaponMu.Unlock()
}</span>

// UpdatePlayerInput updates a player's input state
func (gs *GameServer) UpdatePlayerInput(playerID string, input InputState) bool <span class="cov8" title="1">{
        return gs.world.UpdatePlayerInput(playerID, input)
}</span>

// GetPlayerState returns a snapshot of a player's state
func (gs *GameServer) GetPlayerState(playerID string) (PlayerState, bool) <span class="cov8" title="1">{
        player, exists := gs.world.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return PlayerState{}, false
        }</span>
        <span class="cov8" title="1">return player.Snapshot(), true</span>
}

// IsRunning returns whether the game server is currently running
func (gs *GameServer) IsRunning() bool <span class="cov8" title="1">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()
        return gs.running
}</span>

// GetWorld returns the game world
func (gs *GameServer) GetWorld() *World <span class="cov0" title="0">{
        return gs.world
}</span>

// SetOnReloadComplete sets the callback for when a player's reload completes
func (gs *GameServer) SetOnReloadComplete(callback func(playerID string)) <span class="cov8" title="1">{
        gs.onReloadComplete = callback
}</span>

// GetWeaponState returns the weapon state for a player
func (gs *GameServer) GetWeaponState(playerID string) *WeaponState <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        defer gs.weaponMu.RUnlock()
        return gs.weaponStates[playerID]
}</span>

// SetWeaponState sets the weapon state for a player
func (gs *GameServer) SetWeaponState(playerID string, weaponState *WeaponState) <span class="cov0" title="0">{
        gs.weaponMu.Lock()
        defer gs.weaponMu.Unlock()
        gs.weaponStates[playerID] = weaponState
}</span>

// PlayerShoot attempts to fire a projectile for the given player
func (gs *GameServer) PlayerShoot(playerID string, aimAngle float64) ShootResult <span class="cov8" title="1">{
        // Check if player exists
        player, exists := gs.world.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedNoPlayer}
        }</span>

        // Get weapon state
        <span class="cov8" title="1">gs.weaponMu.RLock()
        ws := gs.weaponStates[playerID]
        gs.weaponMu.RUnlock()

        if ws == nil </span><span class="cov0" title="0">{
                return ShootResult{Success: false, Reason: ShootFailedNoPlayer}
        }</span>

        // Check if reloading
        <span class="cov8" title="1">if ws.IsReloading </span><span class="cov0" title="0">{
                return ShootResult{Success: false, Reason: ShootFailedReload}
        }</span>

        // Check if magazine is empty
        <span class="cov8" title="1">if ws.IsEmpty() </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedEmpty}
        }</span>

        // Check fire rate cooldown
        <span class="cov8" title="1">if !ws.CanShoot() </span><span class="cov8" title="1">{
                return ShootResult{Success: false, Reason: ShootFailedCooldown}
        }</span>

        // Create projectile at player position
        <span class="cov8" title="1">pos := player.GetPosition()
        proj := gs.projectileManager.CreateProjectile(
                playerID,
                pos,
                aimAngle,
                ws.Weapon.ProjectileSpeed,
        )

        // Record the shot (decrements ammo, sets cooldown)
        ws.RecordShot()

        return ShootResult{
                Success:    true,
                Projectile: proj,
        }</span>
}

// PlayerReload starts the reload process for a player
func (gs *GameServer) PlayerReload(playerID string) bool <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        ws := gs.weaponStates[playerID]
        gs.weaponMu.RUnlock()

        if ws == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if magazine is already full
        <span class="cov8" title="1">if ws.CurrentAmmo &gt;= ws.Weapon.MagazineSize </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">ws.StartReload()
        return ws.IsReloading</span>
}

// checkReloads checks all players for completed reloads
func (gs *GameServer) checkReloads() <span class="cov8" title="1">{
        gs.weaponMu.RLock()
        defer gs.weaponMu.RUnlock()

        for playerID, ws := range gs.weaponStates </span><span class="cov8" title="1">{
                if ws.CheckReloadComplete() </span><span class="cov8" title="1">{
                        // Reload just completed - notify via callback
                        if gs.onReloadComplete != nil </span><span class="cov8" title="1">{
                                gs.onReloadComplete(playerID)
                        }</span>
                }
        }
}

// GetActiveProjectiles returns snapshots of all active projectiles
func (gs *GameServer) GetActiveProjectiles() []ProjectileSnapshot <span class="cov8" title="1">{
        return gs.projectileManager.GetProjectileSnapshots()
}</span>

// SetOnHit sets the callback for when a projectile hits a player
func (gs *GameServer) SetOnHit(callback func(hit HitEvent)) <span class="cov8" title="1">{
        gs.onHit = callback
}</span>

// SetOnRespawn sets the callback for when a player respawns
func (gs *GameServer) SetOnRespawn(callback func(playerID string, position Vector2)) <span class="cov0" title="0">{
        gs.onRespawn = callback
}</span>

// SetOnWeaponPickup sets the callback for when a weapon is picked up
func (gs *GameServer) SetOnWeaponPickup(callback func(playerID, crateID, weaponType string, respawnTime time.Time)) <span class="cov0" title="0">{
        gs.onWeaponPickup = callback
}</span>

// SetOnWeaponRespawn sets the callback for when a weapon crate respawns
func (gs *GameServer) SetOnWeaponRespawn(callback func(crate *WeaponCrate)) <span class="cov0" title="0">{
        gs.onWeaponRespawn = callback
}</span>

// GetWeaponCrateManager returns the weapon crate manager
func (gs *GameServer) GetWeaponCrateManager() *WeaponCrateManager <span class="cov0" title="0">{
        return gs.weaponCrateManager
}</span>

// MarkPlayerDead marks a player as dead
func (gs *GameServer) MarkPlayerDead(playerID string) <span class="cov8" title="1">{
        player, exists := gs.world.GetPlayer(playerID)
        if exists </span><span class="cov8" title="1">{
                player.MarkDead()
        }</span>
}

// DamagePlayer applies damage to a player (for testing purposes)
func (gs *GameServer) DamagePlayer(playerID string, damage int) <span class="cov8" title="1">{
        player, exists := gs.world.GetPlayer(playerID)
        if exists </span><span class="cov8" title="1">{
                player.TakeDamage(damage)
        }</span>
}

// checkHitDetection checks for projectile-player collisions and processes hits
func (gs *GameServer) checkHitDetection() <span class="cov8" title="1">{
        // Get all active projectiles
        projectiles := gs.projectileManager.GetActiveProjectiles()
        if len(projectiles) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Get all players
        <span class="cov8" title="1">gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        if len(players) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for collisions
        <span class="cov8" title="1">hits := gs.physics.CheckAllProjectileCollisions(projectiles, players)

        // Process each hit
        for _, hit := range hits </span><span class="cov8" title="1">{
                // Get the attacker's weapon to determine damage
                gs.weaponMu.RLock()
                weaponState := gs.weaponStates[hit.AttackerID]
                gs.weaponMu.RUnlock()

                if weaponState == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">damage := weaponState.Weapon.Damage

                // Apply damage to victim
                victim, exists := gs.world.GetPlayer(hit.VictimID)
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">victim.TakeDamage(damage)

                // Deactivate the projectile
                gs.projectileManager.RemoveProjectile(hit.ProjectileID)

                // Notify via callback
                if gs.onHit != nil </span><span class="cov8" title="1">{
                        gs.onHit(hit)
                }</span>
        }
}

// checkRespawns checks all dead players and respawns them if ready
func (gs *GameServer) checkRespawns() <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Check each player for respawn
        for _, player := range players </span><span class="cov8" title="1">{
                if player.IsDead() &amp;&amp; player.CanRespawn() </span><span class="cov8" title="1">{
                        // Get balanced spawn point
                        spawnPos := gs.world.GetBalancedSpawnPoint(player.ID)

                        // Respawn the player
                        player.Respawn(spawnPos)

                        // Reset weapon state to default pistol (AC: "respawn with default pistol")
                        gs.mu.Lock()
                        gs.weaponStates[player.ID] = NewWeaponStateWithClock(NewPistol(), gs.clock)
                        gs.mu.Unlock()

                        // Notify via callback
                        if gs.onRespawn != nil </span><span class="cov0" title="0">{
                                gs.onRespawn(player.ID, spawnPos)
                        }</span>
                }
        }
}

// updateInvulnerability updates invulnerability status for all players
func (gs *GameServer) updateInvulnerability() <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        // Update each player's invulnerability
        for _, player := range players </span><span class="cov8" title="1">{
                player.UpdateInvulnerability()
        }</span>
}

// updateHealthRegeneration applies health regeneration to all players
func (gs *GameServer) updateHealthRegeneration(deltaTime float64) <span class="cov8" title="1">{
        // Get all players
        gs.world.mu.RLock()
        players := make([]*PlayerState, 0, len(gs.world.players))
        for _, player := range gs.world.players </span><span class="cov8" title="1">{
                players = append(players, player)
        }</span>
        <span class="cov8" title="1">gs.world.mu.RUnlock()

        now := gs.clock.Now()

        // Update each player's regeneration
        for _, player := range players </span><span class="cov8" title="1">{
                // Update regeneration state
                player.UpdateRegenerationState(now)

                // Apply regeneration if applicable
                player.ApplyRegeneration(now, deltaTime)
        }</span>
}

// checkWeaponRespawns checks for weapon crates that should respawn
func (gs *GameServer) checkWeaponRespawns() <span class="cov8" title="1">{
        // Get list of crates that respawned
        respawnedCrates := gs.weaponCrateManager.UpdateRespawns()

        // Notify about each respawned crate
        for _, crateID := range respawnedCrates </span><span class="cov0" title="0">{
                crate := gs.weaponCrateManager.GetCrate(crateID)
                if crate != nil &amp;&amp; gs.onWeaponRespawn != nil </span><span class="cov0" title="0">{
                        gs.onWeaponRespawn(crate)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package game

import (
        "sync"
        "time"
)

// MatchState represents the current state of a match
type MatchState string

const (
        MatchStateWaiting MatchState = "waiting" // Waiting for players
        MatchStateActive  MatchState = "active"  // Match in progress
        MatchStateEnded   MatchState = "ended"   // Match completed
)

// MatchConfig contains configuration for a match
type MatchConfig struct {
        KillTarget       int // Number of kills needed to win (e.g., 20)
        TimeLimitSeconds int // Time limit in seconds (e.g., 420 = 7 minutes)
}

// PlayerScore represents a player's final score in a match
type PlayerScore struct {
        PlayerID string `json:"playerId"`
        Kills    int    `json:"kills"`
        Deaths   int    `json:"deaths"`
        XP       int    `json:"xp"`
}

// Match represents a game match with win conditions and state tracking
type Match struct {
        Config      MatchConfig
        State       MatchState
        StartTime   time.Time
        EndReason   string         // "kill_target" or "time_limit"
        PlayerKills map[string]int // Maps player ID to kill count
        mu          sync.RWMutex
}

// NewMatch creates a new match with default configuration
func NewMatch() *Match <span class="cov8" title="1">{
        return &amp;Match{
                Config: MatchConfig{
                        KillTarget:       20,
                        TimeLimitSeconds: 420, // 7 minutes
                },
                State:       MatchStateWaiting,
                PlayerKills: make(map[string]int),
        }
}</span>

// SetTestMode configures the match for fast testing
// Reduces kill target to 2 and time limit to 10 seconds
func (m *Match) SetTestMode() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Config.KillTarget = 2
        m.Config.TimeLimitSeconds = 10
}</span>

// Start begins the match and records the start time
func (m *Match) Start() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Don't restart if already active
        if m.State == MatchStateActive </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.State = MatchStateActive
        m.StartTime = time.Now()</span>
}

// GetRemainingSeconds calculates the remaining time in the match
func (m *Match) GetRemainingSeconds() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // If match not started, return full time
        if m.StartTime.IsZero() </span><span class="cov8" title="1">{
                return m.Config.TimeLimitSeconds
        }</span>

        <span class="cov8" title="1">elapsed := int(time.Since(m.StartTime).Seconds())
        remaining := m.Config.TimeLimitSeconds - elapsed

        if remaining &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return remaining</span>
}

// AddKill increments the kill count for a player
func (m *Match) AddKill(playerID string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.PlayerKills[playerID]++
}</span>

// CheckKillTarget checks if any player has reached the kill target
func (m *Match) CheckKillTarget() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills &gt;= m.Config.KillTarget </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// CheckTimeLimit checks if the time limit has been reached
func (m *Match) CheckTimeLimit() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // If match not started, time limit not reached
        if m.StartTime.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">elapsed := time.Since(m.StartTime).Seconds()
        return elapsed &gt;= float64(m.Config.TimeLimitSeconds)</span>
}

// EndMatch ends the match with the given reason
func (m *Match) EndMatch(reason string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Only end once
        if m.State == MatchStateEnded </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.State = MatchStateEnded
        m.EndReason = reason</span>
}

// IsEnded returns true if the match has ended
func (m *Match) IsEnded() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return m.State == MatchStateEnded
}</span>

// DetermineWinners analyzes PlayerKills and returns player IDs with the highest kill count
// Returns multiple IDs in case of a tie
func (m *Match) DetermineWinners() []string <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Handle empty match
        if len(m.PlayerKills) == 0 </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        // Find the maximum kill count
        <span class="cov8" title="1">maxKills := 0
        for _, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills &gt; maxKills </span><span class="cov8" title="1">{
                        maxKills = kills
                }</span>
        }

        // Collect all players with the maximum kill count
        <span class="cov8" title="1">winners := []string{}
        for playerID, kills := range m.PlayerKills </span><span class="cov8" title="1">{
                if kills == maxKills </span><span class="cov8" title="1">{
                        winners = append(winners, playerID)
                }</span>
        }

        <span class="cov8" title="1">return winners</span>
}

// GetFinalScores collects final scores for all players in the match
func (m *Match) GetFinalScores(world *World) []PlayerScore <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        scores := []PlayerScore{}

        // Get all players from the world
        world.mu.RLock()
        defer world.mu.RUnlock()

        for playerID := range m.PlayerKills </span><span class="cov8" title="1">{
                player, exists := world.players[playerID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create score entry with player stats
                <span class="cov8" title="1">score := PlayerScore{
                        PlayerID: playerID,
                        Kills:    player.Kills,
                        Deaths:   player.Deaths,
                        XP:       player.XP,
                }
                scores = append(scores, score)</span>
        }

        <span class="cov8" title="1">return scores</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package game

import (
        "math"
)

// MeleeAttackResult represents the result of a melee attack
type MeleeAttackResult struct {
        HitPlayers       []*PlayerState // Players that were hit
        KnockbackApplied bool           // Whether knockback was applied
}

// PerformMeleeAttack executes a melee attack from an attacker
// Returns a result containing all players hit and whether knockback was applied
func PerformMeleeAttack(attacker *PlayerState, allPlayers []*PlayerState, weapon *Weapon) *MeleeAttackResult <span class="cov8" title="1">{
        if weapon == nil || !weapon.IsMelee() </span><span class="cov8" title="1">{
                return &amp;MeleeAttackResult{
                        HitPlayers:       []*PlayerState{},
                        KnockbackApplied: false,
                }
        }</span>

        <span class="cov8" title="1">result := &amp;MeleeAttackResult{
                HitPlayers:       make([]*PlayerState, 0),
                KnockbackApplied: false,
        }

        // Check each potential target
        for _, target := range allPlayers </span><span class="cov8" title="1">{
                // Skip self
                if target.ID == attacker.ID </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Skip dead players
                <span class="cov8" title="1">if !target.IsAlive() </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if target is within range and arc
                <span class="cov8" title="1">if isInMeleeRange(attacker, target, weapon) </span><span class="cov8" title="1">{
                        result.HitPlayers = append(result.HitPlayers, target)

                        // Apply damage using thread-safe method
                        target.TakeDamage(weapon.Damage)

                        // Apply knockback if weapon has it (Bat only)
                        if weapon.KnockbackDistance &gt; 0 </span><span class="cov8" title="1">{
                                applyKnockback(attacker, target, weapon.KnockbackDistance)
                                result.KnockbackApplied = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// isInMeleeRange checks if target is within the melee weapon's range and arc
func isInMeleeRange(attacker *PlayerState, target *PlayerState, weapon *Weapon) bool <span class="cov8" title="1">{
        // Get positions (thread-safe)
        attackerPos := attacker.GetPosition()
        targetPos := target.GetPosition()
        aimAngle := attacker.GetAimAngle()

        // Calculate distance between attacker and target
        dx := targetPos.X - attackerPos.X
        dy := targetPos.Y - attackerPos.Y
        distance := math.Sqrt(dx*dx + dy*dy)

        // Check if within range
        if distance &gt; weapon.Range </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if within arc (cone in front of player based on aim direction)
        // Calculate angle from attacker to target
        <span class="cov8" title="1">angleToTarget := math.Atan2(dy, dx) * (180 / math.Pi)

        // Normalize angles to [0, 360)
        if angleToTarget &lt; 0 </span><span class="cov8" title="1">{
                angleToTarget += 360
        }</span>
        <span class="cov8" title="1">aimAngleDeg := aimAngle * (180 / math.Pi) // Convert radians to degrees
        if aimAngleDeg &lt; 0 </span><span class="cov8" title="1">{
                aimAngleDeg += 360
        }</span>

        // Calculate angular difference
        <span class="cov8" title="1">angleDiff := math.Abs(angleToTarget - aimAngleDeg)
        if angleDiff &gt; 180 </span><span class="cov8" title="1">{
                angleDiff = 360 - angleDiff
        }</span>

        // Check if within arc (weapon.ArcDegrees is the full cone, so half on each side)
        <span class="cov8" title="1">halfArc := weapon.ArcDegrees / 2
        return angleDiff &lt;= halfArc</span>
}

// applyKnockback applies knockback to a target based on direction from attacker
// Knockback velocity is 200 px/s for 0.2s = 40px total displacement
func applyKnockback(attacker *PlayerState, target *PlayerState, knockbackDistance float64) <span class="cov8" title="1">{
        // Get positions (thread-safe)
        attackerPos := attacker.GetPosition()
        targetPos := target.GetPosition()

        // Calculate direction from attacker to target
        dx := targetPos.X - attackerPos.X
        dy := targetPos.Y - attackerPos.Y
        distance := math.Sqrt(dx*dx + dy*dy)

        if distance == 0 </span><span class="cov8" title="1">{
                return // No knockback if exactly on top of each other
        }</span>

        // Normalize direction vector
        <span class="cov8" title="1">dirX := dx / distance
        dirY := dy / distance

        // Apply knockback distance
        // Story 3.2 specifies: 200 px/s for 0.2s = 40px
        // We apply the displacement directly to position
        newX := targetPos.X + dirX*knockbackDistance
        newY := targetPos.Y + dirY*knockbackDistance

        // Ensure target stays within arena bounds
        if newX &lt; 0 </span><span class="cov0" title="0">{
                newX = 0
        }</span>
        <span class="cov8" title="1">if newX &gt; ArenaWidth </span><span class="cov8" title="1">{
                newX = ArenaWidth
        }</span>
        <span class="cov8" title="1">if newY &lt; 0 </span><span class="cov0" title="0">{
                newY = 0
        }</span>
        <span class="cov8" title="1">if newY &gt; ArenaHeight </span><span class="cov0" title="0">{
                newY = ArenaHeight
        }</span>

        // Update position (thread-safe)
        <span class="cov8" title="1">target.SetPosition(Vector2{X: newX, Y: newY})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package game

import (
        "log"
        "math"
)

// Physics handles game physics calculations
type Physics struct{}

// NewPhysics creates a new physics engine
func NewPhysics() *Physics <span class="cov8" title="1">{
        return &amp;Physics{}
}</span>

// UpdatePlayer updates a player's physics state based on input and delta time
// deltaTime is in seconds
func (p *Physics) UpdatePlayer(player *PlayerState, deltaTime float64) <span class="cov8" title="1">{
        input := player.GetInput()
        currentVel := player.GetVelocity()

        // Calculate input direction vector
        inputDir := Vector2{X: 0, Y: 0}

        if input.Left </span><span class="cov8" title="1">{
                inputDir.X -= 1
        }</span>
        <span class="cov8" title="1">if input.Right </span><span class="cov8" title="1">{
                inputDir.X += 1
        }</span>
        <span class="cov8" title="1">if input.Up </span><span class="cov8" title="1">{
                inputDir.Y -= 1
        }</span>
        <span class="cov8" title="1">if input.Down </span><span class="cov8" title="1">{
                inputDir.Y += 1
        }</span>

        // Normalize input direction for diagonal movement
        <span class="cov8" title="1">inputDir = normalize(inputDir)

        // Apply acceleration or deceleration
        var newVel Vector2
        if inputDir.X != 0 || inputDir.Y != 0 </span><span class="cov8" title="1">{
                // Player is giving input - accelerate toward target velocity
                targetVel := Vector2{
                        X: inputDir.X * MovementSpeed,
                        Y: inputDir.Y * MovementSpeed,
                }

                newVel = accelerateToward(currentVel, targetVel, Acceleration, deltaTime)
        }</span> else<span class="cov8" title="1"> {
                // No input - decelerate to zero
                newVel = decelerateToZero(currentVel, Deceleration, deltaTime)
        }</span>

        // Sanitize velocity before setting it
        <span class="cov8" title="1">newVel = sanitizeVector2(newVel, "UpdatePlayer velocity")
        player.SetVelocity(newVel)

        // Update position based on velocity
        currentPos := player.GetPosition()
        newPos := Vector2{
                X: currentPos.X + newVel.X*deltaTime,
                Y: currentPos.Y + newVel.Y*deltaTime,
        }

        // Clamp position to arena bounds
        newPos = clampToArena(newPos)

        // Sanitize position before setting it
        newPos = sanitizeVector2(newPos, "UpdatePlayer position")
        player.SetPosition(newPos)</span>
}

// normalize returns a normalized vector (length = 1) or zero vector if input is zero
func normalize(v Vector2) Vector2 <span class="cov8" title="1">{
        length := math.Sqrt(v.X*v.X + v.Y*v.Y)
        if length == 0 </span><span class="cov8" title="1">{
                return Vector2{X: 0, Y: 0}
        }</span>
        <span class="cov8" title="1">return Vector2{
                X: v.X / length,
                Y: v.Y / length,
        }</span>
}

// accelerateToward smoothly accelerates current velocity toward target velocity
func accelerateToward(current, target Vector2, accel, deltaTime float64) Vector2 <span class="cov8" title="1">{
        diff := Vector2{
                X: target.X - current.X,
                Y: target.Y - current.Y,
        }

        // Calculate the maximum change possible this frame
        maxChange := accel * deltaTime

        // If we're close enough, just snap to target
        diffLength := math.Sqrt(diff.X*diff.X + diff.Y*diff.Y)
        if diffLength &lt;= maxChange </span><span class="cov8" title="1">{
                return target
        }</span>

        // Otherwise, move toward target by maxChange amount
        <span class="cov8" title="1">diffNorm := Vector2{
                X: diff.X / diffLength,
                Y: diff.Y / diffLength,
        }

        return Vector2{
                X: current.X + diffNorm.X*maxChange,
                Y: current.Y + diffNorm.Y*maxChange,
        }</span>
}

// decelerateToZero smoothly decelerates velocity to zero
func decelerateToZero(current Vector2, decel, deltaTime float64) Vector2 <span class="cov8" title="1">{
        return accelerateToward(current, Vector2{X: 0, Y: 0}, decel, deltaTime)
}</span>

// clampToArena ensures position stays within arena bounds
func clampToArena(pos Vector2) Vector2 <span class="cov8" title="1">{
        // Clamp to arena boundaries (accounting for player size)
        halfWidth := PlayerWidth / 2
        halfHeight := PlayerHeight / 2

        x := math.Max(halfWidth, math.Min(pos.X, ArenaWidth-halfWidth))
        y := math.Max(halfHeight, math.Min(pos.Y, ArenaHeight-halfHeight))

        return Vector2{X: x, Y: y}
}</span>

// HitEvent represents a successful projectile hit
type HitEvent struct {
        ProjectileID string
        VictimID     string
        AttackerID   string
}

// calculateDistance returns the Euclidean distance between two positions
func calculateDistance(pos1, pos2 Vector2) float64 <span class="cov8" title="1">{
        dx := pos2.X - pos1.X
        dy := pos2.Y - pos1.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>

// sanitizeVector2 ensures a Vector2 contains no NaN or Inf values
// If NaN or Inf is detected, it's replaced with 0 and logged as an error
func sanitizeVector2(v Vector2, context string) Vector2 <span class="cov8" title="1">{
        result := v
        sanitized := false

        if math.IsNaN(v.X) || math.IsInf(v.X, 0) </span><span class="cov0" title="0">{
                log.Printf("ERROR: %s contains invalid X value: %v, replacing with 0", context, v.X)
                result.X = 0
                sanitized = true
        }</span>
        <span class="cov8" title="1">if math.IsNaN(v.Y) || math.IsInf(v.Y, 0) </span><span class="cov0" title="0">{
                log.Printf("ERROR: %s contains invalid Y value: %v, replacing with 0", context, v.Y)
                result.Y = 0
                sanitized = true
        }</span>

        <span class="cov8" title="1">if sanitized </span><span class="cov0" title="0">{
                log.Printf("WARNING: %s sanitized from %+v to %+v", context, v, result)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// CheckPlayerCrateProximity checks if a player is within pickup range of a weapon crate
// Pickup range is defined by WeaponPickupRadius constant (32px from Story 3.1)
// Returns false if crate is unavailable or player is dead
func (p *Physics) CheckPlayerCrateProximity(player *PlayerState, crate *WeaponCrate) bool <span class="cov8" title="1">{
        // Don't allow pickup if crate is unavailable
        if !crate.IsAvailable </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't allow dead players to pick up weapons
        <span class="cov8" title="1">if !player.IsAlive() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Calculate distance between player and crate
        <span class="cov8" title="1">playerPos := player.GetPosition()
        distance := calculateDistance(playerPos, crate.Position)

        // Check if within pickup radius
        return distance &lt;= WeaponPickupRadius</span>
}

// CheckProjectilePlayerCollision checks if a projectile intersects a player's hitbox using AABB
// Hitbox is 32x64 pixels (PlayerWidth x PlayerHeight) centered on player position
// Returns true if collision detected
func (p *Physics) CheckProjectilePlayerCollision(proj *Projectile, player *PlayerState) bool <span class="cov8" title="1">{
        // Don't check collision with dead players
        if !player.IsAlive() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't check collision with invulnerable players (spawn protection)
        <span class="cov8" title="1">if player.IsInvulnerable </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't check collision with owner
        <span class="cov8" title="1">if proj.OwnerID == player.ID </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">playerPos := player.GetPosition()

        // Validate range: reject hits beyond max projectile range
        // This prevents impossible long-range hits
        distanceTraveled := calculateDistance(proj.SpawnPosition, proj.Position)
        if distanceTraveled &gt; ProjectileMaxRange </span><span class="cov8" title="1">{
                return false
        }</span>

        // Calculate half-sizes for AABB collision
        <span class="cov8" title="1">halfWidth := PlayerWidth / 2
        halfHeight := PlayerHeight / 2

        // AABB collision detection
        // Check if projectile point is within the player's bounding box
        if math.Abs(proj.Position.X-playerPos.X) &lt; halfWidth &amp;&amp;
                math.Abs(proj.Position.Y-playerPos.Y) &lt; halfHeight </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// CheckAllProjectileCollisions checks all projectiles against all players
// Returns a slice of HitEvents for all detected collisions
func (p *Physics) CheckAllProjectileCollisions(projectiles []*Projectile, players []*PlayerState) []HitEvent <span class="cov8" title="1">{
        hits := make([]HitEvent, 0)

        for _, proj := range projectiles </span><span class="cov8" title="1">{
                if !proj.Active </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, player := range players </span><span class="cov8" title="1">{
                        if p.CheckProjectilePlayerCollision(proj, player) </span><span class="cov8" title="1">{
                                hits = append(hits, HitEvent{
                                        ProjectileID: proj.ID,
                                        VictimID:     player.ID,
                                        AttackerID:   proj.OwnerID,
                                })
                                break</span> // Each projectile can only hit one player
                        }
                }
        }

        <span class="cov8" title="1">return hits</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package game

import (
        "sync"
        "time"
)

// Vector2 represents a 2D vector for position and velocity
type Vector2 struct {
        X float64 `json:"x"`
        Y float64 `json:"y"`
}

// InputState represents the player's current input (WASD keys and aim)
type InputState struct {
        Up       bool    `json:"up"`       // W key
        Down     bool    `json:"down"`     // S key
        Left     bool    `json:"left"`     // A key
        Right    bool    `json:"right"`    // D key
        AimAngle float64 `json:"aimAngle"` // Aim angle in radians
}

// PlayerState represents a player's physics state in the game world
type PlayerState struct {
        ID                     string     `json:"id"`
        Position               Vector2    `json:"position"`
        Velocity               Vector2    `json:"velocity"`
        AimAngle               float64    `json:"aimAngle"`            // Aim angle in radians
        Health                 int        `json:"health"`              // Current health (0-100)
        IsInvulnerable         bool       `json:"isInvulnerable"`      // Spawn protection flag
        InvulnerabilityEndTime time.Time  `json:"invulnerabilityEnd"`  // When spawn protection ends
        DeathTime              *time.Time `json:"deathTime,omitempty"` // When player died (nil if alive)
        Kills                  int        `json:"kills"`               // Number of kills
        Deaths                 int        `json:"deaths"`              // Number of deaths
        XP                     int        `json:"xp"`                  // Experience points
        IsRegeneratingHealth   bool       `json:"isRegenerating"`      // Whether health is currently regenerating
        lastDamageTime         time.Time  // Private field: when player last took damage
        regenAccumulator       float64    // Private field: accumulated fractional HP for regeneration
        input                  InputState // Private field, accessed via methods
        clock                  Clock      // Private field: clock for time operations (injectable for testing)
        mu                     sync.RWMutex
}

// NewPlayerState creates a new player state with default spawn position and real clock
func NewPlayerState(id string) *PlayerState <span class="cov8" title="1">{
        return NewPlayerStateWithClock(id, &amp;RealClock{})
}</span>

// NewPlayerStateWithClock creates a new player state with a custom clock (for testing)
func NewPlayerStateWithClock(id string, clock Clock) *PlayerState <span class="cov8" title="1">{
        return &amp;PlayerState{
                ID: id,
                Position: Vector2{
                        X: ArenaWidth / 2,
                        Y: ArenaHeight / 2,
                },
                Velocity:       Vector2{X: 0, Y: 0},
                Health:         PlayerMaxHealth,
                input:          InputState{},
                clock:          clock,
                lastDamageTime: clock.Now(), // Initialize to prevent immediate regeneration
        }
}</span>

// SetInput updates the player's input state (thread-safe)
func (p *PlayerState) SetInput(input InputState) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.input = input
}</span>

// GetInput retrieves the player's input state (thread-safe)
func (p *PlayerState) GetInput() InputState <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.input
}</span>

// SetPosition updates the player's position (thread-safe)
func (p *PlayerState) SetPosition(pos Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Position = pos
}</span>

// GetPosition retrieves the player's position (thread-safe)
func (p *PlayerState) GetPosition() Vector2 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Position
}</span>

// SetVelocity updates the player's velocity (thread-safe)
func (p *PlayerState) SetVelocity(vel Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Velocity = vel
}</span>

// GetVelocity retrieves the player's velocity (thread-safe)
func (p *PlayerState) GetVelocity() Vector2 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Velocity
}</span>

// SetAimAngle updates the player's aim angle (thread-safe)
func (p *PlayerState) SetAimAngle(angle float64) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.AimAngle = angle
}</span>

// GetAimAngle retrieves the player's aim angle (thread-safe)
func (p *PlayerState) GetAimAngle() float64 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.AimAngle
}</span>

// TakeDamage reduces the player's health by the given amount (thread-safe)
// Health will not go below 0
// Updates lastDamageTime to reset regeneration timer
func (p *PlayerState) TakeDamage(amount int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Health -= amount
        if p.Health &lt; 0 </span><span class="cov8" title="1">{
                p.Health = 0
        }</span>
        <span class="cov8" title="1">p.lastDamageTime = p.clock.Now()
        p.IsRegeneratingHealth = false // Stop regeneration when taking damage
        p.regenAccumulator = 0.0</span>       // Reset regeneration accumulator
}

// IsAlive returns true if the player has health remaining (thread-safe)
func (p *PlayerState) IsAlive() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.Health &gt; 0
}</span>

// Snapshot returns a thread-safe copy of the player's current state
func (p *PlayerState) Snapshot() PlayerState <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return PlayerState{
                ID:                     p.ID,
                Position:               p.Position,
                Velocity:               p.Velocity,
                AimAngle:               p.AimAngle,
                Health:                 p.Health,
                IsInvulnerable:         p.IsInvulnerable,
                InvulnerabilityEndTime: p.InvulnerabilityEndTime,
                DeathTime:              p.DeathTime,
                Kills:                  p.Kills,
                Deaths:                 p.Deaths,
                XP:                     p.XP,
                IsRegeneratingHealth:   p.IsRegeneratingHealth,
        }
}</span>

// MarkDead marks the player as dead and records the death time (thread-safe)
func (p *PlayerState) MarkDead() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        now := p.clock.Now()
        p.DeathTime = &amp;now
        p.Health = 0
}</span>

// IsDead returns true if the player is currently dead (thread-safe)
func (p *PlayerState) IsDead() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.DeathTime != nil
}</span>

// CanRespawn returns true if the respawn delay has passed (thread-safe)
func (p *PlayerState) CanRespawn() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        if p.DeathTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return p.clock.Since(*p.DeathTime).Seconds() &gt;= RespawnDelay</span>
}

// Respawn resets the player to alive state at the given position (thread-safe)
func (p *PlayerState) Respawn(spawnPos Vector2) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Health = PlayerMaxHealth
        p.Position = spawnPos
        p.Velocity = Vector2{X: 0, Y: 0}
        p.DeathTime = nil
        p.IsInvulnerable = true
        p.InvulnerabilityEndTime = p.clock.Now().Add(time.Duration(SpawnInvulnerabilityDuration * float64(time.Second)))
        p.regenAccumulator = 0.0         // Clear regeneration accumulator on respawn
        p.lastDamageTime = p.clock.Now() // Reset regeneration timer to prevent immediate regeneration
}</span>

// UpdateInvulnerability checks and updates invulnerability status (thread-safe)
func (p *PlayerState) UpdateInvulnerability() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.IsInvulnerable &amp;&amp; p.clock.Now().After(p.InvulnerabilityEndTime) </span><span class="cov8" title="1">{
                p.IsInvulnerable = false
        }</span>
}

// IncrementKills increments the player's kill count (thread-safe)
func (p *PlayerState) IncrementKills() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Kills++
}</span>

// IncrementDeaths increments the player's death count (thread-safe)
func (p *PlayerState) IncrementDeaths() <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.Deaths++
}</span>

// AddXP adds experience points to the player (thread-safe)
func (p *PlayerState) AddXP(amount int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.XP += amount
}</span>

// GetKDRatio calculates the kill/death ratio (thread-safe)
// Returns 0 if player has no kills or deaths
func (p *PlayerState) GetKDRatio() float64 <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        if p.Deaths == 0 </span><span class="cov8" title="1">{
                return float64(p.Kills)
        }</span>
        <span class="cov8" title="1">return float64(p.Kills) / float64(p.Deaths)</span>
}

// GetLastDamageTime returns the time when the player last took damage (thread-safe)
func (p *PlayerState) GetLastDamageTime() time.Time <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.lastDamageTime
}</span>

// CanRegenerate checks if the player can regenerate health at the given time (thread-safe)
// Returns true if enough time has passed since last damage and health is below max
func (p *PlayerState) CanRegenerate(now time.Time) bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        // Cannot regenerate if dead
        if p.DeathTime != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Cannot regenerate if at full health
        <span class="cov8" title="1">if p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if enough time has passed since last damage
        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        return timeSinceLastDamage &gt;= HealthRegenerationDelay</span>
}

// ApplyRegeneration applies health regeneration for the given deltaTime (thread-safe)
// Only regenerates if conditions are met (delay passed, not at max health, not dead)
func (p *PlayerState) ApplyRegeneration(now time.Time, deltaTime float64) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if we can regenerate
        if p.DeathTime != nil || p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        if timeSinceLastDamage &lt; HealthRegenerationDelay </span><span class="cov8" title="1">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        // Apply regeneration using accumulator for fractional HP
        // At 60Hz tick rate (deltaTime  0.0167s), HealthRegenerationRate * deltaTime  0.167 HP
        // We accumulate fractional HP and only apply full HP when accumulator &gt;= 1.0
        <span class="cov8" title="1">p.regenAccumulator += HealthRegenerationRate * deltaTime

        // Apply accumulated HP as integer value
        if p.regenAccumulator &gt;= 1.0 </span><span class="cov8" title="1">{
                regenAmount := int(p.regenAccumulator)
                p.Health += regenAmount
                p.regenAccumulator -= float64(regenAmount) // Keep the fractional remainder
        }</span>

        // Cap at max health and clear accumulator
        <span class="cov8" title="1">if p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                p.Health = PlayerMaxHealth
                p.regenAccumulator = 0.0 // Clear accumulator at max health
        }</span>

        // Update regeneration state
        <span class="cov8" title="1">p.IsRegeneratingHealth = p.Health &lt; PlayerMaxHealth</span>
}

// UpdateRegenerationState updates the IsRegeneratingHealth flag based on current conditions (thread-safe)
func (p *PlayerState) UpdateRegenerationState(now time.Time) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Update regeneration state
        if p.DeathTime != nil || p.Health &gt;= PlayerMaxHealth </span><span class="cov8" title="1">{
                p.IsRegeneratingHealth = false
                return
        }</span>

        <span class="cov8" title="1">timeSinceLastDamage := now.Sub(p.lastDamageTime).Seconds()
        p.IsRegeneratingHealth = timeSinceLastDamage &gt;= HealthRegenerationDelay</span>
}

// IsRegenerating returns whether the player is currently regenerating health (thread-safe)
func (p *PlayerState) IsRegenerating() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.IsRegeneratingHealth
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package game

import (
        "math"
        "sync"
        "time"

        "github.com/google/uuid"
)

// Projectile represents a bullet/projectile in the game world
type Projectile struct {
        ID            string    `json:"id"`
        OwnerID       string    `json:"ownerId"`
        Position      Vector2   `json:"position"`
        Velocity      Vector2   `json:"velocity"`
        SpawnPosition Vector2   `json:"-"` // Initial position for range validation
        CreatedAt     time.Time `json:"-"`
        Active        bool      `json:"-"`
}

// ProjectileSnapshot is the network-transmittable version of Projectile
type ProjectileSnapshot struct {
        ID       string  `json:"id"`
        OwnerID  string  `json:"ownerId"`
        Position Vector2 `json:"position"`
        Velocity Vector2 `json:"velocity"`
}

// NewProjectile creates a new projectile with calculated velocity from angle
func NewProjectile(ownerID string, startPos Vector2, aimAngle float64, speed float64) *Projectile <span class="cov8" title="1">{
        return &amp;Projectile{
                ID:            uuid.New().String(),
                OwnerID:       ownerID,
                Position:      startPos,
                SpawnPosition: startPos, // Store spawn position for range validation
                Velocity: Vector2{
                        X: math.Cos(aimAngle) * speed,
                        Y: math.Sin(aimAngle) * speed,
                },
                CreatedAt: time.Now(),
                Active:    true,
        }
}</span>

// Update moves the projectile based on velocity and delta time
func (p *Projectile) Update(deltaTime float64) <span class="cov8" title="1">{
        p.Position.X += p.Velocity.X * deltaTime
        p.Position.Y += p.Velocity.Y * deltaTime
}</span>

// IsExpired returns true if the projectile has exceeded its max lifetime
func (p *Projectile) IsExpired() bool <span class="cov8" title="1">{
        return time.Since(p.CreatedAt) &gt;= ProjectileMaxLifetime
}</span>

// IsOutOfBounds returns true if the projectile is outside the arena
func (p *Projectile) IsOutOfBounds() bool <span class="cov8" title="1">{
        return p.Position.X &lt; 0 || p.Position.X &gt; ArenaWidth ||
                p.Position.Y &lt; 0 || p.Position.Y &gt; ArenaHeight
}</span>

// Deactivate marks the projectile as inactive (for removal)
func (p *Projectile) Deactivate() <span class="cov8" title="1">{
        p.Active = false
}</span>

// Snapshot returns a copy of the projectile state for network transmission
func (p *Projectile) Snapshot() ProjectileSnapshot <span class="cov8" title="1">{
        return ProjectileSnapshot{
                ID:       p.ID,
                OwnerID:  p.OwnerID,
                Position: p.Position,
                Velocity: p.Velocity,
        }
}</span>

// ProjectileManager manages all active projectiles in the game
type ProjectileManager struct {
        projectiles map[string]*Projectile
        mu          sync.RWMutex
}

// NewProjectileManager creates a new projectile manager
func NewProjectileManager() *ProjectileManager <span class="cov8" title="1">{
        return &amp;ProjectileManager{
                projectiles: make(map[string]*Projectile),
        }
}</span>

// CreateProjectile creates and adds a new projectile
func (pm *ProjectileManager) CreateProjectile(ownerID string, startPos Vector2, aimAngle float64, speed float64) *Projectile <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        proj := NewProjectile(ownerID, startPos, aimAngle, speed)
        pm.projectiles[proj.ID] = proj
        return proj
}</span>

// Update updates all projectiles and removes inactive ones
func (pm *ProjectileManager) Update(deltaTime float64) <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        // Collect IDs to remove
        toRemove := make([]string, 0)

        for id, proj := range pm.projectiles </span><span class="cov8" title="1">{
                // Check if projectile should be removed
                if !proj.Active || proj.IsExpired() || proj.IsOutOfBounds() </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, id)
                        continue</span>
                }

                // Update position
                <span class="cov8" title="1">proj.Update(deltaTime)

                // Check bounds after update
                if proj.IsOutOfBounds() </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, id)
                }</span>
        }

        // Remove inactive projectiles
        <span class="cov8" title="1">for _, id := range toRemove </span><span class="cov8" title="1">{
                delete(pm.projectiles, id)
        }</span>
}

// GetActiveProjectiles returns a slice of all active projectiles
func (pm *ProjectileManager) GetActiveProjectiles() []*Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]*Projectile, 0, len(pm.projectiles))
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetProjectileByID returns a projectile by its ID, or nil if not found
func (pm *ProjectileManager) GetProjectileByID(id string) *Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        return pm.projectiles[id]
}</span>

// RemoveProjectile removes a projectile by its ID
func (pm *ProjectileManager) RemoveProjectile(id string) <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        delete(pm.projectiles, id)
}</span>

// GetProjectilesByOwner returns all projectiles owned by a specific player
func (pm *ProjectileManager) GetProjectilesByOwner(ownerID string) []*Projectile <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]*Projectile, 0)
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.OwnerID == ownerID &amp;&amp; proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetProjectileSnapshots returns snapshots of all active projectiles for network transmission
func (pm *ProjectileManager) GetProjectileSnapshots() []ProjectileSnapshot <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        result := make([]ProjectileSnapshot, 0, len(pm.projectiles))
        for _, proj := range pm.projectiles </span><span class="cov8" title="1">{
                if proj.Active </span><span class="cov8" title="1">{
                        result = append(result, proj.Snapshot())
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package game

import (
        "encoding/json"
        "errors"
        "log"
        "os"
        "sync"
        "time"

        "github.com/google/uuid"
)

// Player represents a connected player
type Player struct {
        ID       string
        SendChan chan []byte
}

// Room represents a game room with multiple players
type Room struct {
        ID         string
        Players    []*Player
        MaxPlayers int
        Match      *Match // Match state tracking
        mu         sync.RWMutex
}

// NewRoom creates a new room with a unique ID
func NewRoom() *Room <span class="cov8" title="1">{
        match := NewMatch()

        // Enable test mode if TEST_MODE environment variable is set
        if os.Getenv("TEST_MODE") == "true" </span><span class="cov0" title="0">{
                match.SetTestMode()
                log.Println("Match created in TEST MODE (kill target: 2, time limit: 10s)")
        }</span>

        <span class="cov8" title="1">return &amp;Room{
                ID:         uuid.New().String(),
                Players:    make([]*Player, 0, 8),
                MaxPlayers: 8,
                Match:      match,
        }</span>
}

// AddPlayer adds a player to the room
func (r *Room) AddPlayer(player *Player) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if len(r.Players) &gt;= r.MaxPlayers </span><span class="cov8" title="1">{
                return errors.New("room is full")
        }</span>

        <span class="cov8" title="1">r.Players = append(r.Players, player)
        return nil</span>
}

// RemovePlayer removes a player from the room by ID
func (r *Room) RemovePlayer(playerID string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Remove player from slice
                        r.Players = append(r.Players[:i], r.Players[i+1:]...)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsEmpty returns true if the room has no players (thread-safe)
func (r *Room) IsEmpty() bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.Players) == 0
}</span>

// PlayerCount returns the number of players in the room (thread-safe)
func (r *Room) PlayerCount() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.Players)
}</span>

// Broadcast sends a message to all players in the room, optionally excluding a sender
func (r *Room) Broadcast(message []byte, excludePlayerID string) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        for _, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID != excludePlayerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                log.Printf("Warning: Could not send message to player %s (channel closed)", player.ID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- message:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov8" title="1">
                                        log.Printf("Warning: Could not send message to player %s (channel full)", player.ID)</span>
                                }
                        }()
                }
        }
}

// GetPlayer returns a player by ID, or nil if not found
func (r *Room) GetPlayer(playerID string) *Player <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        for _, player := range r.Players </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        return player
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPlayers returns a copy of all players in the room
func (r *Room) GetPlayers() []*Player <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Return a copy to avoid race conditions
        players := make([]*Player, len(r.Players))
        copy(players, r.Players)
        return players
}</span>

// RoomManager manages all game rooms and player assignments
type RoomManager struct {
        rooms          map[string]*Room
        waitingPlayers []*Player
        playerToRoom   map[string]string // Maps player ID to room ID
        mu             sync.RWMutex
}

// NewRoomManager creates a new room manager
func NewRoomManager() *RoomManager <span class="cov8" title="1">{
        return &amp;RoomManager{
                rooms:          make(map[string]*Room),
                waitingPlayers: make([]*Player, 0),
                playerToRoom:   make(map[string]string),
        }
}</span>

// AddPlayer adds a player and creates a room if we have 2 waiting players
func (rm *RoomManager) AddPlayer(player *Player) *Room <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Add to waiting list
        rm.waitingPlayers = append(rm.waitingPlayers, player)

        // If we have 2 players, create a room
        if len(rm.waitingPlayers) &gt;= 2 </span><span class="cov8" title="1">{
                // Create new room
                room := NewRoom()

                // Add both waiting players to the room
                player1 := rm.waitingPlayers[0]
                player2 := rm.waitingPlayers[1]

                room.AddPlayer(player1)
                room.AddPlayer(player2)

                // Clear waiting list
                rm.waitingPlayers = rm.waitingPlayers[2:]

                // Register room
                rm.rooms[room.ID] = room
                rm.playerToRoom[player1.ID] = room.ID
                rm.playerToRoom[player2.ID] = room.ID

                // Start the match
                room.Match.Start()

                // Log room creation
                log.Printf("Room created: %s with players: [%s, %s]", room.ID, player1.ID, player2.ID)

                // Send room:joined messages to both players
                rm.sendRoomJoinedMessage(player1, room)
                rm.sendRoomJoinedMessage(player2, room)

                return room
        }</span>

        // Not enough players yet
        <span class="cov8" title="1">return nil</span>
}

// sendRoomJoinedMessage sends a room:joined message to a player
func (rm *RoomManager) sendRoomJoinedMessage(player *Player, room *Room) <span class="cov8" title="1">{
        message := map[string]interface{}{
                "type":      "room:joined",
                "timestamp": time.Now().UnixMilli(),
                "data": map[string]interface{}{
                        "roomId":   room.ID,
                        "playerId": player.ID,
                },
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling room:joined message: %v", err)
                return
        }</span>

        // Use recover to handle closed channel panics gracefully
        <span class="cov8" title="1">func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Could not send room:joined message to player %s (channel closed)", player.ID)
                        }</span>
                }()

                <span class="cov8" title="1">select </span>{
                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                        // Message sent successfully
                default:<span class="cov0" title="0">
                        log.Printf("Warning: Could not send room:joined message to player %s (channel full)", player.ID)</span>
                }
        }()
}

// RemovePlayer removes a player from their room and notifies other players
func (rm *RoomManager) RemovePlayer(playerID string) <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Find and remove from waiting list if present
        for i, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        rm.waitingPlayers = append(rm.waitingPlayers[:i], rm.waitingPlayers[i+1:]...)
                        return
                }</span>
        }

        // Find player's room
        <span class="cov8" title="1">roomID, exists := rm.playerToRoom[playerID]
        if !exists </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">room, exists := rm.rooms[roomID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove player from room
        <span class="cov8" title="1">room.RemovePlayer(playerID)

        // Send player:left message to remaining players
        message := map[string]interface{}{
                "type":      "player:left",
                "timestamp": time.Now().UnixMilli(),
                "data": map[string]interface{}{
                        "playerId": playerID,
                },
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:left message: %v", err)
        }</span> else<span class="cov8" title="1"> {
                room.Broadcast(msgBytes, "")
        }</span>

        // Clean up player to room mapping
        <span class="cov8" title="1">delete(rm.playerToRoom, playerID)

        // If room is empty, remove it
        if room.IsEmpty() </span><span class="cov8" title="1">{
                delete(rm.rooms, roomID)
                log.Printf("Room %s removed (no players remaining)", roomID)
        }</span>
}

// GetRoomByPlayerID finds a room by player ID
func (rm *RoomManager) GetRoomByPlayerID(playerID string) *Room <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        roomID, exists := rm.playerToRoom[playerID]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return rm.rooms[roomID]</span>
}

// SendToWaitingPlayer sends a message to a waiting player (not in a room yet)
func (rm *RoomManager) SendToWaitingPlayer(playerID string, msgBytes []byte) <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                log.Printf("Warning: Could not send message to waiting player %s (channel closed)", playerID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov8" title="1">
                                        log.Printf("Warning: Could not send message to waiting player %s (channel full)", playerID)</span>
                                }
                        }()
                        <span class="cov8" title="1">return</span>
                }
        }
}

// SendToPlayer sends a message to any player (in room or waiting)
// Returns true if player was found and message was queued, false otherwise
func (rm *RoomManager) SendToPlayer(playerID string, msgBytes []byte) bool <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        // First, check if player is in a room
        roomID, inRoom := rm.playerToRoom[playerID]
        if inRoom </span><span class="cov8" title="1">{
                room, roomExists := rm.rooms[roomID]
                if roomExists </span><span class="cov8" title="1">{
                        player := room.GetPlayer(playerID)
                        if player != nil </span><span class="cov8" title="1">{
                                // Use recover to handle closed channel panics gracefully
                                func() </span><span class="cov8" title="1">{
                                        defer func() </span><span class="cov8" title="1">{
                                                if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                                        log.Printf("Warning: Could not send message to player %s (channel closed)", playerID)
                                                }</span>
                                        }()

                                        <span class="cov8" title="1">select </span>{
                                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                                // Message sent successfully
                                        default:<span class="cov8" title="1">
                                                log.Printf("Warning: Could not send message to player %s (channel full)", playerID)</span>
                                        }
                                }()
                                <span class="cov8" title="1">return true</span>
                        }
                }
        }

        // Second, check waiting players
        <span class="cov8" title="1">for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                if player.ID == playerID </span><span class="cov8" title="1">{
                        // Use recover to handle closed channel panics gracefully
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                                log.Printf("Warning: Could not send message to waiting player %s (channel closed)", playerID)
                                        }</span>
                                }()

                                <span class="cov8" title="1">select </span>{
                                case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                        // Message sent successfully
                                default:<span class="cov0" title="0">
                                        log.Printf("Warning: Could not send message to waiting player %s (channel full)", playerID)</span>
                                }
                        }()
                        <span class="cov8" title="1">return true</span>
                }
        }

        // Player not found
        <span class="cov8" title="1">return false</span>
}

// BroadcastToAll sends a message to all players (in rooms and waiting)
func (rm *RoomManager) BroadcastToAll(msgBytes []byte) <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        // Broadcast to all rooms
        for _, room := range rm.rooms </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>

        // Send to all waiting players
        <span class="cov8" title="1">for _, player := range rm.waitingPlayers </span><span class="cov8" title="1">{
                // Use recover to handle closed channel panics gracefully
                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                        log.Printf("Warning: Could not send message to waiting player %s (channel closed)", player.ID)
                                }</span>
                        }()

                        <span class="cov8" title="1">select </span>{
                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                // Message sent successfully
                        default:<span class="cov8" title="1">
                                log.Printf("Warning: Could not send message to waiting player %s (channel full)", player.ID)</span>
                        }
                }()
        }
}

// GetAllRooms returns a snapshot of all active rooms (thread-safe)
func (rm *RoomManager) GetAllRooms() []*Room <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rooms := make([]*Room, 0, len(rm.rooms))
        for _, room := range rm.rooms </span><span class="cov8" title="1">{
                rooms = append(rooms, room)
        }</span>
        <span class="cov8" title="1">return rooms</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package game

import (
        "time"
)

// Weapon constants for Pistol (from Story 2.3 requirements)
const (
        // PistolDamage is the damage per shot (25 damage = 4 shots to kill at 100 health)
        PistolDamage = 25

        // PistolFireRate is rounds per second (3 rounds/sec = 333ms cooldown)
        PistolFireRate = 3.0

        // PistolMagazineSize is the number of rounds before reload required
        PistolMagazineSize = 15

        // PistolReloadTime is the time required to reload in milliseconds
        PistolReloadTime = 1500 * time.Millisecond

        // PistolProjectileSpeed is the projectile travel speed in pixels per second
        PistolProjectileSpeed = 800.0

        // ProjectileMaxLifetime is the maximum time a projectile exists (1 second)
        ProjectileMaxLifetime = 1 * time.Second

        // ProjectileMaxRange is the maximum range for hit detection (px)
        // Set to projectile speed * lifetime = 800px/s * 1s = 800px
        ProjectileMaxRange = 800.0
)

// Weapon defines a weapon type with its properties
type Weapon struct {
        Name              string
        Damage            int
        FireRate          float64       // Rounds per second (or swings per second for melee)
        MagazineSize      int           // Rounds per magazine (0 for melee)
        ReloadTime        time.Duration // Time to reload (0 for melee)
        ProjectileSpeed   float64       // Projectile speed in px/s (0 for melee)
        Range             float64       // Maximum range in pixels (for melee and ranged)
        ArcDegrees        float64       // Swing arc in degrees (for melee, 0 for ranged)
        KnockbackDistance float64       // Knockback distance in pixels (Bat only)
}

// IsMelee returns true if this is a melee weapon
func (w *Weapon) IsMelee() bool <span class="cov8" title="1">{
        return w.MagazineSize == 0 &amp;&amp; w.ProjectileSpeed == 0
}</span>

// NewPistol creates a new Pistol weapon instance
func NewPistol() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "Pistol",
                Damage:            PistolDamage,
                FireRate:          PistolFireRate,
                MagazineSize:      PistolMagazineSize,
                ReloadTime:        PistolReloadTime,
                ProjectileSpeed:   PistolProjectileSpeed,
                Range:             ProjectileMaxRange,
                ArcDegrees:        0,
                KnockbackDistance: 0,
        }
}</span>

// WeaponState tracks the current state of a player's weapon
type WeaponState struct {
        Weapon          *Weapon
        CurrentAmmo     int
        IsReloading     bool
        LastShotTime    time.Time
        ReloadStartTime time.Time
        clock           Clock // Clock for time operations (injectable for testing)
}

// NewWeaponState creates a new weapon state with full ammo and real clock
func NewWeaponState(weapon *Weapon) *WeaponState <span class="cov8" title="1">{
        return NewWeaponStateWithClock(weapon, &amp;RealClock{})
}</span>

// NewWeaponStateWithClock creates a new weapon state with a custom clock (for testing)
func NewWeaponStateWithClock(weapon *Weapon, clock Clock) *WeaponState <span class="cov8" title="1">{
        return &amp;WeaponState{
                Weapon:      weapon,
                CurrentAmmo: weapon.MagazineSize,
                IsReloading: false,
                clock:       clock,
        }
}</span>

// CanShoot returns true if the weapon can fire (or swing for melee)
func (ws *WeaponState) CanShoot() bool <span class="cov8" title="1">{
        // Melee weapons bypass ammo and reload checks
        isMelee := ws.Weapon.IsMelee()

        // Cannot shoot while reloading (ranged only)
        if !isMelee &amp;&amp; ws.IsReloading </span><span class="cov8" title="1">{
                return false
        }</span>

        // Cannot shoot with empty magazine (ranged only)
        <span class="cov8" title="1">if !isMelee &amp;&amp; ws.CurrentAmmo &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check fire rate cooldown (both melee and ranged)
        <span class="cov8" title="1">if !ws.LastShotTime.IsZero() </span><span class="cov8" title="1">{
                cooldown := time.Duration(float64(time.Second) / ws.Weapon.FireRate)
                if ws.clock.Since(ws.LastShotTime) &lt; cooldown </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// RecordShot records that a shot was fired (or swing for melee), decrements ammo for ranged weapons
func (ws *WeaponState) RecordShot() <span class="cov8" title="1">{
        // Only decrement ammo for ranged weapons
        if !ws.Weapon.IsMelee() &amp;&amp; ws.CurrentAmmo &gt; 0 </span><span class="cov8" title="1">{
                ws.CurrentAmmo--
        }</span>
        <span class="cov8" title="1">ws.LastShotTime = ws.clock.Now()</span>
}

// StartReload begins the reload process
func (ws *WeaponState) StartReload() <span class="cov8" title="1">{
        // Don't reload if already reloading
        if ws.IsReloading </span><span class="cov8" title="1">{
                return
        }</span>

        // Don't reload if magazine is full
        <span class="cov8" title="1">if ws.CurrentAmmo &gt;= ws.Weapon.MagazineSize </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ws.IsReloading = true
        ws.ReloadStartTime = ws.clock.Now()</span>
}

// CheckReloadComplete checks if reload is done and refills ammo if so
// Returns true if reload just completed
func (ws *WeaponState) CheckReloadComplete() bool <span class="cov8" title="1">{
        if !ws.IsReloading </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if ws.clock.Since(ws.ReloadStartTime) &gt;= ws.Weapon.ReloadTime </span><span class="cov8" title="1">{
                ws.CurrentAmmo = ws.Weapon.MagazineSize
                ws.IsReloading = false
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// IsEmpty returns true if the magazine is empty
func (ws *WeaponState) IsEmpty() bool <span class="cov8" title="1">{
        return ws.CurrentAmmo &lt;= 0
}</span>

// GetAmmoInfo returns current and max ammo
func (ws *WeaponState) GetAmmoInfo() (current, max int) <span class="cov8" title="1">{
        return ws.CurrentAmmo, ws.Weapon.MagazineSize
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package game

import (
        "fmt"
        "sync"
        "time"
)

// WeaponCrate represents a weapon spawn point on the map
type WeaponCrate struct {
        ID          string
        Position    Vector2
        WeaponType  string
        IsAvailable bool
        RespawnTime time.Time
}

// WeaponCrateManager manages all weapon crates in the game
type WeaponCrateManager struct {
        crates map[string]*WeaponCrate
        mu     sync.RWMutex
}

// NewWeaponCrateManager creates a new weapon crate manager with default spawn points
func NewWeaponCrateManager() *WeaponCrateManager <span class="cov8" title="1">{
        manager := &amp;WeaponCrateManager{
                crates: make(map[string]*WeaponCrate),
        }
        manager.InitializeDefaultSpawns()
        return manager
}</span>

// InitializeDefaultSpawns creates the default weapon spawn points for the arena
// Based on the weapon acquisition system design (Story 3.3A):
// - 5 fixed spawn points (one for each non-pistol weapon)
// - Balanced positions across the map
// - Strategic placement considering weapon power levels
func (wcm *WeaponCrateManager) InitializeDefaultSpawns() <span class="cov8" title="1">{
        spawns := []struct {
                Position   Vector2
                WeaponType string
        }{
                // Center top - Uzi (medium range, spray weapon)
                {Position: Vector2{X: ArenaWidth / 2, Y: ArenaHeight * 0.2}, WeaponType: "uzi"},

                // Left mid - AK47 (powerful long-range weapon, contested position)
                {Position: Vector2{X: ArenaWidth * 0.25, Y: ArenaHeight / 2}, WeaponType: "ak47"},

                // Right mid - Shotgun (close-range power weapon)
                {Position: Vector2{X: ArenaWidth * 0.75, Y: ArenaHeight / 2}, WeaponType: "shotgun"},

                // Bottom center - Katana (melee, high skill weapon)
                {Position: Vector2{X: ArenaWidth / 2, Y: ArenaHeight * 0.8}, WeaponType: "katana"},

                // Top left corner - Bat (melee, knockback weapon)
                {Position: Vector2{X: ArenaWidth * 0.15, Y: ArenaHeight * 0.15}, WeaponType: "bat"},
        }

        for i, spawn := range spawns </span><span class="cov8" title="1">{
                crateID := fmt.Sprintf("crate_%s_%d", spawn.WeaponType, i)
                wcm.crates[crateID] = &amp;WeaponCrate{
                        ID:          crateID,
                        Position:    spawn.Position,
                        WeaponType:  spawn.WeaponType,
                        IsAvailable: true,
                }
        }</span>
}

// PickupCrate attempts to pick up a weapon crate
// Returns true if pickup was successful, false if crate doesn't exist or is unavailable
func (wcm *WeaponCrateManager) PickupCrate(crateID string) bool <span class="cov8" title="1">{
        wcm.mu.Lock()
        defer wcm.mu.Unlock()

        crate, exists := wcm.crates[crateID]
        if !exists || !crate.IsAvailable </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">crate.IsAvailable = false
        crate.RespawnTime = time.Now().Add(WeaponRespawnDelay * time.Second)
        return true</span>
}

// UpdateRespawns checks for crates that should respawn and makes them available again
// Returns a slice of crate IDs that respawned
func (wcm *WeaponCrateManager) UpdateRespawns() []string <span class="cov8" title="1">{
        wcm.mu.Lock()
        defer wcm.mu.Unlock()

        respawned := make([]string, 0)
        now := time.Now()

        for id, crate := range wcm.crates </span><span class="cov8" title="1">{
                if !crate.IsAvailable &amp;&amp; now.After(crate.RespawnTime) </span><span class="cov8" title="1">{
                        crate.IsAvailable = true
                        respawned = append(respawned, id)
                }</span>
        }

        <span class="cov8" title="1">return respawned</span>
}

// GetCrate returns a weapon crate by ID
// Returns nil if crate doesn't exist
func (wcm *WeaponCrateManager) GetCrate(crateID string) *WeaponCrate <span class="cov8" title="1">{
        wcm.mu.RLock()
        defer wcm.mu.RUnlock()

        return wcm.crates[crateID]
}</span>

// GetAllCrates returns a copy of all weapon crates
// Returns a map copy to prevent external modification
func (wcm *WeaponCrateManager) GetAllCrates() map[string]*WeaponCrate <span class="cov8" title="1">{
        wcm.mu.RLock()
        defer wcm.mu.RUnlock()

        // Return a shallow copy of the map
        crates := make(map[string]*WeaponCrate, len(wcm.crates))
        for id, crate := range wcm.crates </span><span class="cov8" title="1">{
                crates[id] = crate
        }</span>
        <span class="cov8" title="1">return crates</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package game

import (
        "fmt"
        "strings"
        "time"
)

// NewBat creates a new Bat weapon instance
// Stats from weapon-balance-analysis.md and Story 3.2:
// - Damage: 25
// - Fire Rate: 2.0/s (0.5s cooldown)
// - Range: 64px (melee)
// - Arc: 90 degrees
// - Knockback: 40px (200 px/s for 0.2s)
func NewBat() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "Bat",
                Damage:            25,
                FireRate:          2.0,
                MagazineSize:      0,  // Melee has no ammo
                ReloadTime:        0,  // Melee has no reload
                ProjectileSpeed:   0,  // Melee has no projectiles
                Range:             64, // 64px melee range
                ArcDegrees:        90, // 90-degree swing arc
                KnockbackDistance: 40, // 40px knockback
        }
}</span>

// NewKatana creates a new Katana weapon instance
// Stats from weapon-balance-analysis.md and Story 3.2:
// - Damage: 45
// - Fire Rate: 1.25/s (0.8s cooldown)
// - Range: 80px (melee)
// - Arc: 90 degrees
// - Knockback: None
func NewKatana() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "Katana",
                Damage:            45,
                FireRate:          1.25,
                MagazineSize:      0,  // Melee has no ammo
                ReloadTime:        0,  // Melee has no reload
                ProjectileSpeed:   0,  // Melee has no projectiles
                Range:             80, // 80px melee range (longer than Bat)
                ArcDegrees:        90, // 90-degree swing arc
                KnockbackDistance: 0,  // No knockback
        }
}</span>

// NewUzi creates a new Uzi weapon instance
// Stats from weapon-balance-analysis.md:
// - Damage: 8
// - Fire Rate: 10.0/s
// - Magazine Size: 30
// - Reload Time: 1.5s
// - Range: 600px
func NewUzi() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "Uzi",
                Damage:            8,
                FireRate:          10.0,
                MagazineSize:      30,
                ReloadTime:        1500 * time.Millisecond,
                ProjectileSpeed:   800.0,
                Range:             600,
                ArcDegrees:        0,
                KnockbackDistance: 0,
        }
}</span>

// NewAK47 creates a new AK47 weapon instance
// Stats from weapon-balance-analysis.md:
// - Damage: 20
// - Fire Rate: 6.0/s
// - Magazine Size: 30
// - Reload Time: 2.0s
// - Range: 800px
func NewAK47() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "AK47",
                Damage:            20,
                FireRate:          6.0,
                MagazineSize:      30,
                ReloadTime:        2000 * time.Millisecond,
                ProjectileSpeed:   800.0,
                Range:             800,
                ArcDegrees:        0,
                KnockbackDistance: 0,
        }
}</span>

// NewShotgun creates a new Shotgun weapon instance
// Stats from weapon-balance-analysis.md:
// - Damage: 60 total (8 pellets x 7.5 damage each)
// - Fire Rate: 1.0/s
// - Magazine Size: 6
// - Reload Time: 2.5s
// - Range: 300px
func NewShotgun() *Weapon <span class="cov8" title="1">{
        return &amp;Weapon{
                Name:              "Shotgun",
                Damage:            60, // Total damage for all 8 pellets
                FireRate:          1.0,
                MagazineSize:      6,
                ReloadTime:        2500 * time.Millisecond,
                ProjectileSpeed:   800.0,
                Range:             300,
                ArcDegrees:        0,
                KnockbackDistance: 0,
        }
}</span>

// CreateWeaponByType creates a weapon instance based on the weapon type string
// Weapon type strings are case-insensitive
// Returns error if weapon type is invalid
func CreateWeaponByType(weaponType string) (*Weapon, error) <span class="cov8" title="1">{
        switch strings.ToLower(weaponType) </span>{
        case "bat":<span class="cov8" title="1">
                return NewBat(), nil</span>
        case "katana":<span class="cov8" title="1">
                return NewKatana(), nil</span>
        case "uzi":<span class="cov8" title="1">
                return NewUzi(), nil</span>
        case "ak47":<span class="cov8" title="1">
                return NewAK47(), nil</span>
        case "shotgun":<span class="cov8" title="1">
                return NewShotgun(), nil</span>
        case "pistol":<span class="cov8" title="1">
                return NewPistol(), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid weapon type: %s", weaponType)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package game

import (
        "math"
        "math/rand"
        "sync"
)

// World manages the game state and all players
type World struct {
        players map[string]*PlayerState
        clock   Clock
        mu      sync.RWMutex
}

// NewWorld creates a new game world with a real clock
func NewWorld() *World <span class="cov8" title="1">{
        return NewWorldWithClock(&amp;RealClock{})
}</span>

// NewWorldWithClock creates a new game world with a custom clock (for testing)
func NewWorldWithClock(clock Clock) *World <span class="cov8" title="1">{
        return &amp;World{
                players: make(map[string]*PlayerState),
                clock:   clock,
        }
}</span>

// AddPlayer adds a new player to the world
func (w *World) AddPlayer(playerID string) *PlayerState <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        player := NewPlayerStateWithClock(playerID, w.clock)
        w.players[playerID] = player
        return player
}</span>

// RemovePlayer removes a player from the world
func (w *World) RemovePlayer(playerID string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        delete(w.players, playerID)
}</span>

// GetPlayer retrieves a player by ID
func (w *World) GetPlayer(playerID string) (*PlayerState, bool) <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        player, exists := w.players[playerID]
        return player, exists
}</span>

// GetAllPlayers returns snapshots of all players (thread-safe)
func (w *World) GetAllPlayers() []PlayerState <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        snapshots := make([]PlayerState, 0, len(w.players))
        for _, player := range w.players </span><span class="cov8" title="1">{
                snapshots = append(snapshots, player.Snapshot())
        }</span>
        <span class="cov8" title="1">return snapshots</span>
}

// PlayerCount returns the number of players in the world
func (w *World) PlayerCount() int <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return len(w.players)
}</span>

// UpdatePlayerInput updates a player's input state
func (w *World) UpdatePlayerInput(playerID string, input InputState) bool <span class="cov8" title="1">{
        player, exists := w.GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">player.SetInput(input)
        // Also update the player's aim angle for broadcasting
        player.SetAimAngle(input.AimAngle)
        return true</span>
}

// GetBalancedSpawnPoint finds a spawn point furthest from all living enemy players
// Returns the center position if no enemies are present
func (w *World) GetBalancedSpawnPoint(excludePlayerID string) Vector2 <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Collect positions of all living enemy players
        enemyPositions := make([]Vector2, 0)
        for id, player := range w.players </span><span class="cov8" title="1">{
                if id != excludePlayerID &amp;&amp; !player.IsDead() </span><span class="cov8" title="1">{
                        enemyPositions = append(enemyPositions, player.GetPosition())
                }</span>
        }

        // If no enemies, spawn at center
        <span class="cov8" title="1">if len(enemyPositions) == 0 </span><span class="cov8" title="1">{
                return Vector2{X: ArenaWidth / 2, Y: ArenaHeight / 2}
        }</span>

        // Try 10 random spawn candidates and pick the one furthest from enemies
        <span class="cov8" title="1">bestSpawn := Vector2{X: ArenaWidth / 2, Y: ArenaHeight / 2}
        bestMinDistance := 0.0

        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                // Generate random spawn point with margin from edges
                margin := 100.0
                candidate := Vector2{
                        X: margin + rand.Float64()*(ArenaWidth-2*margin),
                        Y: margin + rand.Float64()*(ArenaHeight-2*margin),
                }

                // Find minimum distance to any enemy
                minDistance := math.MaxFloat64
                for _, enemyPos := range enemyPositions </span><span class="cov8" title="1">{
                        dist := distance(candidate, enemyPos)
                        if dist &lt; minDistance </span><span class="cov8" title="1">{
                                minDistance = dist
                        }</span>
                }

                // Keep the spawn point with the largest minimum distance
                <span class="cov8" title="1">if minDistance &gt; bestMinDistance </span><span class="cov8" title="1">{
                        bestMinDistance = minDistance
                        bestSpawn = candidate
                }</span>
        }

        <span class="cov8" title="1">return bestSpawn</span>
}

// distance calculates the Euclidean distance between two points
func distance(a, b Vector2) float64 <span class="cov8" title="1">{
        dx := a.X - b.X
        dy := a.Y - b.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
