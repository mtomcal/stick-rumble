
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>network: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mtomcal/stick-rumble-server/internal/network/broadcast_helper.go (76.0%)</option>
				
				<option value="file1">github.com/mtomcal/stick-rumble-server/internal/network/message_processor.go (77.8%)</option>
				
				<option value="file2">github.com/mtomcal/stick-rumble-server/internal/network/schema_loader.go (93.3%)</option>
				
				<option value="file3">github.com/mtomcal/stick-rumble-server/internal/network/schema_validator.go (94.7%)</option>
				
				<option value="file4">github.com/mtomcal/stick-rumble-server/internal/network/websocket_handler.go (88.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package network

import (
        "encoding/json"
        "log"
        "math"
        "time"

        "github.com/mtomcal/stick-rumble-server/internal/game"
)

// broadcastPlayerStates sends player position updates to all players
func (h *WebSocketHandler) broadcastPlayerStates(playerStates []game.PlayerState) <span class="cov8" title="1">{
        if len(playerStates) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Validate player states for NaN/Inf values before marshaling
        <span class="cov8" title="1">for i := range playerStates </span><span class="cov8" title="1">{
                state := &amp;playerStates[i]
                if math.IsNaN(state.Position.X) || math.IsNaN(state.Position.Y) ||
                        math.IsInf(state.Position.X, 0) || math.IsInf(state.Position.Y, 0) </span><span class="cov8" title="1">{
                        log.Printf("ERROR: Player %s has invalid position: %+v", state.ID, state.Position)
                }</span>
                <span class="cov8" title="1">if math.IsNaN(state.Velocity.X) || math.IsNaN(state.Velocity.Y) ||
                        math.IsInf(state.Velocity.X, 0) || math.IsInf(state.Velocity.Y, 0) </span><span class="cov8" title="1">{
                        log.Printf("ERROR: Player %s has invalid velocity: %+v", state.ID, state.Velocity)
                }</span>
                <span class="cov8" title="1">if math.IsNaN(state.AimAngle) || math.IsInf(state.AimAngle, 0) </span><span class="cov8" title="1">{
                        log.Printf("ERROR: Player %s has invalid aimAngle: %v", state.ID, state.AimAngle)
                        // Sanitize aim angle to prevent JSON marshal error
                        state.AimAngle = 0
                }</span>
        }

        // Group player state indices by room to avoid broadcasting cross-room player data
        // This prevents the bug where players from different rooms appear in each other's games
        // Using indices to avoid copying PlayerState which contains a mutex
        <span class="cov8" title="1">roomPlayerIndices := make(map[string][]int)
        waitingPlayerIndices := make([]int, 0)

        for i := range playerStates </span><span class="cov8" title="1">{
                room := h.roomManager.GetRoomByPlayerID(playerStates[i].ID)
                if room != nil </span><span class="cov8" title="1">{
                        roomPlayerIndices[room.ID] = append(roomPlayerIndices[room.ID], i)
                }</span> else<span class="cov8" title="1"> {
                        // Player is waiting (not in a room yet)
                        waitingPlayerIndices = append(waitingPlayerIndices, i)
                }</span>
        }

        // Broadcast to each room with only that room's players
        <span class="cov8" title="1">for roomID, indices := range roomPlayerIndices </span><span class="cov8" title="1">{
                // Build player slice for this room only (use pointers to avoid copying mutex)
                roomPlayers := make([]*game.PlayerState, len(indices))
                for j, idx := range indices </span><span class="cov8" title="1">{
                        roomPlayers[j] = &amp;playerStates[idx]
                }</span>

                // Create player:move message data for this room only
                <span class="cov8" title="1">data := map[string]interface{}{
                        "players": roomPlayers,
                }

                // Validate outgoing message schema (development mode only)
                if err := h.validateOutgoingMessage("player:move", data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Schema validation failed for player:move: %v", err)
                        // Continue anyway - validation is for development debugging only
                }</span>

                // Create player:move message
                <span class="cov8" title="1">message := Message{
                        Type:      "player:move",
                        Timestamp: 0, // Will be set by each client
                        Data:      data,
                }

                msgBytes, err := json.Marshal(message)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marshaling player:move message: %v", err)
                        log.Printf("Player states that failed to marshal: %+v", roomPlayers)
                        continue</span>
                }

                // Get room and broadcast
                <span class="cov8" title="1">rooms := h.roomManager.GetAllRooms()
                for _, room := range rooms </span><span class="cov8" title="1">{
                        if room.ID == roomID </span><span class="cov8" title="1">{
                                room.Broadcast(msgBytes, "")
                                break</span>
                        }
                }
        }

        // Send to waiting players (each waiting player only sees their own state)
        <span class="cov8" title="1">for _, idx := range waitingPlayerIndices </span><span class="cov8" title="1">{
                // Use pointer to avoid copying mutex
                state := &amp;playerStates[idx]
                data := map[string]interface{}{
                        "players": []*game.PlayerState{state},
                }

                message := Message{
                        Type:      "player:move",
                        Timestamp: 0,
                        Data:      data,
                }

                msgBytes, err := json.Marshal(message)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error marshaling player:move message for waiting player: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">h.roomManager.SendToWaitingPlayer(state.ID, msgBytes)</span>
        }
}

// broadcastProjectileSpawn sends projectile spawn event to all clients
func (h *WebSocketHandler) broadcastProjectileSpawn(proj *game.Projectile) <span class="cov8" title="1">{
        if proj == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Create projectile:spawn message data
        <span class="cov8" title="1">data := map[string]interface{}{
                "id":       proj.ID,
                "ownerId":  proj.OwnerID,
                "position": proj.Position,
                "velocity": proj.Velocity,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("projectile:spawn", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for projectile:spawn: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "projectile:spawn",
                Timestamp: 0,
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling projectile:spawn message: %v", err)
                return
        }</span>

        // Broadcast to all rooms and waiting players
        <span class="cov8" title="1">h.roomManager.BroadcastToAll(msgBytes)</span>
}

// broadcastMatchTimers broadcasts timer updates to all active rooms
func (h *WebSocketHandler) broadcastMatchTimers() <span class="cov8" title="1">{
        rooms := h.roomManager.GetAllRooms()

        for _, room := range rooms </span><span class="cov8" title="1">{
                // Skip if match ended
                if room.Match.IsEnded() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">remainingSeconds := room.Match.GetRemainingSeconds()

                // Create match:timer message data
                data := map[string]interface{}{
                        "remainingSeconds": remainingSeconds,
                }

                // Validate outgoing message schema (development mode only)
                if err := h.validateOutgoingMessage("match:timer", data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Schema validation failed for match:timer: %v", err)
                }</span>

                // Create match:timer message
                <span class="cov8" title="1">timerMessage := Message{
                        Type:      "match:timer",
                        Timestamp: 0,
                        Data:      data,
                }

                msgBytes, err := json.Marshal(timerMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marshaling match:timer message: %v", err)
                        continue</span>
                }

                // Broadcast to all players in room
                <span class="cov8" title="1">room.Broadcast(msgBytes, "")

                // Check if time limit reached
                if room.Match.CheckTimeLimit() </span><span class="cov0" title="0">{
                        room.Match.EndMatch("time_limit")
                        log.Printf("Match ended in room %s: time limit reached", room.ID)
                        // Broadcast match:ended message to all players
                        h.broadcastMatchEnded(room, h.gameServer.GetWorld())
                }</span>
        }
}

// sendWeaponState sends weapon state update to a specific player
func (h *WebSocketHandler) sendWeaponState(playerID string) <span class="cov8" title="1">{
        ws := h.gameServer.GetWeaponState(playerID)
        if ws == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">current, max := ws.GetAmmoInfo()

        // Create weapon:state message data
        data := map[string]interface{}{
                "currentAmmo": current,
                "maxAmmo":     max,
                "isReloading": ws.IsReloading,
                "canShoot":    ws.CanShoot(),
                "weaponType":  ws.Weapon.Name,
                "isMelee":     ws.Weapon.IsMelee(),
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("weapon:state", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for weapon:state: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "weapon:state",
                Timestamp: 0,
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling weapon:state message: %v", err)
                return
        }</span>

        // Send to the specific player
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                player := room.GetPlayer(playerID)
                if player != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                log.Printf("Failed to send weapon:state to player %s (channel full)", playerID)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                h.roomManager.SendToWaitingPlayer(playerID, msgBytes)
        }</span>
}

// sendShootFailed sends a shoot failure message to the player
func (h *WebSocketHandler) sendShootFailed(playerID string, reason string) <span class="cov8" title="1">{
        // Create shoot:failed message data
        data := map[string]interface{}{
                "reason": reason,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("shoot:failed", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for shoot:failed: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "shoot:failed",
                Timestamp: 0,
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling shoot:failed message: %v", err)
                return
        }</span>

        // Send to the specific player
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                player := room.GetPlayer(playerID)
                if player != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                log.Printf("Failed to send shoot:failed to player %s (channel full)", playerID)</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                h.roomManager.SendToWaitingPlayer(playerID, msgBytes)
        }</span>
}

// broadcastMatchEnded broadcasts match end event to all players in a room
func (h *WebSocketHandler) broadcastMatchEnded(room *game.Room, world *game.World) <span class="cov8" title="1">{
        // Check if match exists
        if room.Match == nil </span><span class="cov8" title="1">{
                log.Printf("Cannot broadcast match ended: match is nil for room %s", room.ID)
                return
        }</span>

        // Determine winners and get final scores
        <span class="cov8" title="1">winners := room.Match.DetermineWinners()
        finalScores := room.Match.GetFinalScores(world)

        // Create match:ended message data
        data := map[string]interface{}{
                "winners":     winners,
                "finalScores": finalScores,
                "reason":      room.Match.EndReason,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("match:ended", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for match:ended: %v", err)
        }</span>

        // Create match:ended message
        <span class="cov8" title="1">message := Message{
                Type:      "match:ended",
                Timestamp: 0,
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling match:ended message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room.Broadcast(msgBytes, "")
        log.Printf("Match ended in room %s - reason: %s, winners: %v", room.ID, room.Match.EndReason, winners)</span>
}

// broadcastWeaponPickup broadcasts weapon pickup event to all clients
func (h *WebSocketHandler) broadcastWeaponPickup(playerID, crateID, weaponType string, respawnTime time.Time) <span class="cov8" title="1">{
        // Create weapon:pickup_confirmed message data
        data := map[string]interface{}{
                "playerId":        playerID,
                "crateId":         crateID,
                "weaponType":      weaponType,
                "nextRespawnTime": respawnTime.Unix(),
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("weapon:pickup_confirmed", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for weapon:pickup_confirmed: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "weapon:pickup_confirmed",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling weapon:pickup_confirmed message: %v", err)
                return
        }</span>

        // Broadcast to all players
        <span class="cov8" title="1">h.roomManager.BroadcastToAll(msgBytes)</span>
}

// broadcastWeaponRespawn broadcasts weapon respawn event to all clients
func (h *WebSocketHandler) broadcastWeaponRespawn(crate *game.WeaponCrate) <span class="cov8" title="1">{
        // Create weapon:respawned message data
        data := map[string]interface{}{
                "crateId":    crate.ID,
                "weaponType": crate.WeaponType,
                "position":   crate.Position,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("weapon:respawned", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for weapon:respawned: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "weapon:respawned",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling weapon:respawned message: %v", err)
                return
        }</span>

        // Broadcast to all players
        <span class="cov8" title="1">h.roomManager.BroadcastToAll(msgBytes)</span>
}

// sendWeaponSpawns sends initial weapon spawn state to a specific player
func (h *WebSocketHandler) sendWeaponSpawns(playerID string) <span class="cov8" title="1">{
        // Get all weapon crates from the manager
        allCrates := h.gameServer.GetWeaponCrateManager().GetAllCrates()

        // Build crates array for the message
        crates := make([]map[string]interface{}, 0, len(allCrates))
        for _, crate := range allCrates </span><span class="cov8" title="1">{
                crateData := map[string]interface{}{
                        "id":          crate.ID,
                        "position":    map[string]interface{}{"x": crate.Position.X, "y": crate.Position.Y},
                        "weaponType":  crate.WeaponType,
                        "isAvailable": crate.IsAvailable,
                }
                crates = append(crates, crateData)
        }</span>

        // Create weapon:spawned message data
        <span class="cov8" title="1">data := map[string]interface{}{
                "crates": crates,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("weapon:spawned", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for weapon:spawned: %v", err)
        }</span>

        // Create weapon:spawned message
        <span class="cov8" title="1">message := Message{
                Type:      "weapon:spawned",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling weapon:spawned message: %v", err)
                return
        }</span>

        // Send to the specific player
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                player := room.GetPlayer(playerID)
                if player != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case player.SendChan &lt;- msgBytes:<span class="cov8" title="1"></span>
                                // Message sent successfully
                        default:<span class="cov0" title="0">
                                log.Printf("Failed to send weapon:spawned to player %s (channel full)", playerID)</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // Player not in a room yet, send to waiting player
                h.roomManager.SendToWaitingPlayer(playerID, msgBytes)
        }</span>
}

// broadcastRollStart broadcasts roll start event to all players in the room
func (h *WebSocketHandler) broadcastRollStart(playerID string, direction game.Vector2, rollStartTime time.Time) <span class="cov8" title="1">{
        // Create roll:start message data
        data := map[string]interface{}{
                "playerId":      playerID,
                "direction":     direction,
                "rollStartTime": rollStartTime.UnixMilli(),
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("roll:start", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for roll:start: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "roll:start",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling roll:start message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>
}

// broadcastMeleeHit broadcasts melee hit event to all players in the room
func (h *WebSocketHandler) broadcastMeleeHit(attackerID string, victimIDs []string, knockbackApplied bool) <span class="cov8" title="1">{
        // Create melee:hit message data
        data := map[string]interface{}{
                "attackerId":       attackerID,
                "victims":          victimIDs,
                "knockbackApplied": knockbackApplied,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("melee:hit", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for melee:hit: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "melee:hit",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling melee:hit message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(attackerID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>
}

// broadcastPlayerDamaged broadcasts player damage event (used by melee attacks)
func (h *WebSocketHandler) broadcastPlayerDamaged(attackerID, victimID string, damage, newHealth int) <span class="cov8" title="1">{
        // Create player:damaged message data
        data := map[string]interface{}{
                "victimId":   victimID,
                "attackerId": attackerID,
                "damage":     damage,
                "newHealth":  newHealth,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("player:damaged", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for player:damaged: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "player:damaged",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:damaged message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(victimID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>
}

// processMeleeKill handles death processing for melee kills
func (h *WebSocketHandler) processMeleeKill(attackerID, victimID string) <span class="cov8" title="1">{
        // Mark player as dead
        h.gameServer.MarkPlayerDead(victimID)

        // Get the actual player pointers to update stats
        attacker, attackerExists := h.gameServer.GetWorld().GetPlayer(attackerID)
        if attackerExists &amp;&amp; attacker != nil </span><span class="cov8" title="1">{
                attacker.IncrementKills()
                attacker.AddXP(game.KillXPReward)
        }</span>

        <span class="cov8" title="1">victim, victimExists := h.gameServer.GetWorld().GetPlayer(victimID)
        if victimExists &amp;&amp; victim != nil </span><span class="cov8" title="1">{
                victim.IncrementDeaths()
        }</span>

        // Create player:death message data
        <span class="cov8" title="1">deathData := map[string]interface{}{
                "victimId":   victimID,
                "attackerId": attackerID,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("player:death", deathData); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for player:death: %v", err)
        }</span>

        <span class="cov8" title="1">deathMessage := Message{
                Type:      "player:death",
                Timestamp: time.Now().UnixMilli(),
                Data:      deathData,
        }

        deathBytes, err := json.Marshal(deathMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:death message: %v", err)
                return
        }</span>

        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(victimID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(deathBytes, "")
        }</span>

        // Create player:kill_credit message data
        <span class="cov8" title="1">killCreditData := map[string]interface{}{
                "killerId":    attackerID,
                "victimId":    victimID,
                "killerKills": 0,
                "killerXP":    0,
        }

        if attackerExists &amp;&amp; attacker != nil </span><span class="cov8" title="1">{
                killCreditData["killerKills"] = attacker.Kills
                killCreditData["killerXP"] = attacker.XP
        }</span>

        // Validate outgoing message schema (development mode only)
        <span class="cov8" title="1">if err := h.validateOutgoingMessage("player:kill_credit", killCreditData); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for player:kill_credit: %v", err)
        }</span>

        // Broadcast kill credit
        <span class="cov8" title="1">killCreditMessage := Message{
                Type:      "player:kill_credit",
                Timestamp: time.Now().UnixMilli(),
                Data:      killCreditData,
        }

        creditBytes, err := json.Marshal(killCreditMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:kill_credit message: %v", err)
                return
        }</span>

        <span class="cov8" title="1">if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(creditBytes, "")

                // Track kill in match and check win conditions
                room.Match.AddKill(attackerID)

                // Check if kill target reached
                if room.Match.CheckKillTarget() </span><span class="cov0" title="0">{
                        room.Match.EndMatch("kill_target")
                        log.Printf("Match ended in room %s: kill target reached (melee)", room.ID)
                        h.broadcastMatchEnded(room, h.gameServer.GetWorld())
                }</span>
        }
}

// broadcastRollEnd broadcasts roll end event to all players in the room
func (h *WebSocketHandler) broadcastRollEnd(playerID string, reason string) <span class="cov8" title="1">{
        // Create roll:end message data
        data := map[string]interface{}{
                "playerId": playerID,
                "reason":   reason,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("roll:end", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for roll:end: %v", err)
        }</span>

        <span class="cov8" title="1">message := Message{
                Type:      "roll:end",
                Timestamp: time.Now().UnixMilli(),
                Data:      data,
        }

        msgBytes, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling roll:end message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package network

import (
        "encoding/json"
        "log"
        "math"

        "github.com/mtomcal/stick-rumble-server/internal/game"
)

// handleInputState processes player input state updates
func (h *WebSocketHandler) handleInputState(playerID string, data any) <span class="cov8" title="1">{
        // Check if player's match has ended - reject input if so
        room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil &amp;&amp; room.Match.IsEnded() </span><span class="cov8" title="1">{
                // Silently ignore input after match ends (AC: "server stops accepting input:state messages")
                return
        }</span>

        // Validate data against JSON schema
        <span class="cov8" title="1">if err := h.validator.Validate("input-state-data", data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Schema validation failed for input:state from %s: %v", playerID, err)
                return
        }</span>

        // After validation, we can safely type assert
        <span class="cov0" title="0">dataMap := data.(map[string]interface{})

        input := game.InputState{
                Up:       dataMap["up"].(bool),
                Down:     dataMap["down"].(bool),
                Left:     dataMap["left"].(bool),
                Right:    dataMap["right"].(bool),
                AimAngle: dataMap["aimAngle"].(float64),
        }

        // Update game server with input
        success := h.gameServer.UpdatePlayerInput(playerID, input)
        if !success </span><span class="cov0" title="0">{
                log.Printf("Failed to update input for player %s", playerID)
        }</span>
}

// handlePlayerShoot processes player shoot messages
func (h *WebSocketHandler) handlePlayerShoot(playerID string, data any) <span class="cov8" title="1">{
        // Validate data against JSON schema
        if err := h.validator.Validate("player-shoot-data", data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Schema validation failed for player:shoot from %s: %v", playerID, err)
                return
        }</span>

        // After validation, we can safely type assert
        <span class="cov8" title="1">dataMap := data.(map[string]interface{})
        aimAngle := dataMap["aimAngle"].(float64)

        // Attempt to shoot
        result := h.gameServer.PlayerShoot(playerID, aimAngle)

        if result.Success </span><span class="cov8" title="1">{
                // Broadcast projectile spawn to all players
                h.broadcastProjectileSpawn(result.Projectile)

                // Send weapon state update to the shooter
                h.sendWeaponState(playerID)
        }</span> else<span class="cov8" title="1"> {
                // Send failure reason to player (for empty click sound, etc.)
                h.sendShootFailed(playerID, result.Reason)
        }</span>
}

// handlePlayerReload processes player reload messages
func (h *WebSocketHandler) handlePlayerReload(playerID string) <span class="cov8" title="1">{
        success := h.gameServer.PlayerReload(playerID)

        if success </span><span class="cov8" title="1">{
                // Send weapon state update to the player
                h.sendWeaponState(playerID)
        }</span>
}

// onReloadComplete is called when a player's reload finishes
func (h *WebSocketHandler) onReloadComplete(playerID string) <span class="cov8" title="1">{
        // Send updated weapon state to the player
        h.sendWeaponState(playerID)
}</span>

// onHit is called when a projectile hits a player
func (h *WebSocketHandler) onHit(hit game.HitEvent) <span class="cov8" title="1">{
        // Get victim's current state (including updated health)
        victimState, victimExists := h.gameServer.GetPlayerState(hit.VictimID)
        if !victimExists </span><span class="cov8" title="1">{
                return
        }</span>

        // Get attacker's weapon to determine damage dealt
        <span class="cov8" title="1">attackerWeapon := h.gameServer.GetWeaponState(hit.AttackerID)
        if attackerWeapon == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">damage := attackerWeapon.Weapon.Damage

        // Create player:damaged message data
        damagedData := map[string]interface{}{
                "victimId":     hit.VictimID,
                "attackerId":   hit.AttackerID,
                "damage":       damage,
                "newHealth":    victimState.Health,
                "projectileId": hit.ProjectileID,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("player:damaged", damagedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for player:damaged: %v", err)
        }</span>

        // Broadcast player:damaged to all players in the room
        <span class="cov8" title="1">damagedMessage := Message{
                Type:      "player:damaged",
                Timestamp: 0,
                Data:      damagedData,
        }

        msgBytes, err := json.Marshal(damagedMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:damaged message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(hit.VictimID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>

        // Create hit:confirmed message data
        <span class="cov8" title="1">hitConfirmedData := map[string]interface{}{
                "victimId":     hit.VictimID,
                "damage":       damage,
                "projectileId": hit.ProjectileID,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("hit:confirmed", hitConfirmedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for hit:confirmed: %v", err)
        }</span>

        // Send hit confirmation to the attacker
        <span class="cov8" title="1">hitConfirmedMessage := Message{
                Type:      "hit:confirmed",
                Timestamp: 0,
                Data:      hitConfirmedData,
        }

        confirmBytes, err := json.Marshal(hitConfirmedMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling hit:confirmed message: %v", err)
                return
        }</span>

        <span class="cov8" title="1">h.roomManager.SendToPlayer(hit.AttackerID, confirmBytes)

        // If victim died, mark as dead and broadcast player:death
        if !victimState.IsAlive() </span><span class="cov8" title="1">{
                // Mark player as dead
                h.gameServer.MarkPlayerDead(hit.VictimID)

                // Update stats: increment attacker kills and victim deaths
                // NOTE: Must use GetWorld().GetPlayer() to get pointer, not GetPlayerState() which returns a copy!
                attacker, attackerExists := h.gameServer.GetWorld().GetPlayer(hit.AttackerID)
                if attackerExists &amp;&amp; attacker != nil </span><span class="cov8" title="1">{
                        attacker.IncrementKills()
                        attacker.AddXP(game.KillXPReward)
                }</span>
                // victimState is already a pointer from earlier in this function
                <span class="cov8" title="1">victim, victimExists := h.gameServer.GetWorld().GetPlayer(hit.VictimID)
                if victimExists &amp;&amp; victim != nil </span><span class="cov8" title="1">{
                        victim.IncrementDeaths()
                }</span>

                // Create player:death message data
                <span class="cov8" title="1">deathData := map[string]interface{}{
                        "victimId":   hit.VictimID,
                        "attackerId": hit.AttackerID,
                }

                // Validate outgoing message schema (development mode only)
                if err := h.validateOutgoingMessage("player:death", deathData); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Schema validation failed for player:death: %v", err)
                }</span>

                <span class="cov8" title="1">deathMessage := Message{
                        Type:      "player:death",
                        Timestamp: 0,
                        Data:      deathData,
                }

                deathBytes, err := json.Marshal(deathMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marshaling player:death message: %v", err)
                        return
                }</span>

                <span class="cov8" title="1">if room != nil </span><span class="cov8" title="1">{
                        room.Broadcast(deathBytes, "")
                }</span>

                // Create player:kill_credit message data
                <span class="cov8" title="1">killerKills := 0
                killerXP := 0
                if attacker != nil </span><span class="cov8" title="1">{
                        killerKills = attacker.Kills
                        killerXP = attacker.XP
                }</span>
                <span class="cov8" title="1">killCreditData := map[string]interface{}{
                        "killerId":    hit.AttackerID,
                        "victimId":    hit.VictimID,
                        "killerKills": killerKills,
                        "killerXP":    killerXP,
                }

                // Validate outgoing message schema (development mode only)
                if err := h.validateOutgoingMessage("player:kill_credit", killCreditData); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Schema validation failed for player:kill_credit: %v", err)
                }</span>

                // Broadcast kill credit with updated stats
                <span class="cov8" title="1">killCreditMessage := Message{
                        Type:      "player:kill_credit",
                        Timestamp: 0,
                        Data:      killCreditData,
                }

                creditBytes, err := json.Marshal(killCreditMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marshaling player:kill_credit message: %v", err)
                        return
                }</span>

                <span class="cov8" title="1">if room != nil </span><span class="cov8" title="1">{
                        room.Broadcast(creditBytes, "")

                        // Track kill in match and check win conditions
                        room.Match.AddKill(hit.AttackerID)

                        // Check if kill target reached
                        if room.Match.CheckKillTarget() </span><span class="cov0" title="0">{
                                room.Match.EndMatch("kill_target")
                                log.Printf("Match ended in room %s: kill target reached", room.ID)
                                // Broadcast match:ended message to all players
                                h.broadcastMatchEnded(room, h.gameServer.GetWorld())
                        }</span>
                }
        }
}

// onRespawn is called when a player respawns after death
func (h *WebSocketHandler) onRespawn(playerID string, position game.Vector2) <span class="cov8" title="1">{
        // Create player:respawn message data
        respawnData := map[string]interface{}{
                "playerId": playerID,
                "position": position,
                "health":   game.PlayerMaxHealth,
        }

        // Validate outgoing message schema (development mode only)
        if err := h.validateOutgoingMessage("player:respawn", respawnData); err != nil </span><span class="cov0" title="0">{
                log.Printf("Schema validation failed for player:respawn: %v", err)
        }</span>

        // Create player:respawn message
        <span class="cov8" title="1">respawnMessage := Message{
                Type:      "player:respawn",
                Timestamp: 0,
                Data:      respawnData,
        }

        msgBytes, err := json.Marshal(respawnMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling player:respawn message: %v", err)
                return
        }</span>

        // Broadcast to all players in the room
        <span class="cov8" title="1">room := h.roomManager.GetRoomByPlayerID(playerID)
        if room != nil </span><span class="cov8" title="1">{
                room.Broadcast(msgBytes, "")
        }</span>
}

// handleWeaponPickup processes weapon pickup attempts from players
func (h *WebSocketHandler) handleWeaponPickup(playerID string, data any) <span class="cov8" title="1">{
        // Validate data against JSON schema
        if err := h.validator.Validate("weapon-pickup-attempt-data", data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Schema validation failed for weapon:pickup_attempt from %s: %v", playerID, err)
                return
        }</span>

        // After validation, we can safely type assert
        <span class="cov8" title="1">dataMap := data.(map[string]interface{})
        crateID := dataMap["crateId"].(string)

        // Get weapon crate
        crate := h.gameServer.GetWeaponCrateManager().GetCrate(crateID)
        if crate == nil </span><span class="cov8" title="1">{
                log.Printf("Invalid crateId %s from player %s", crateID, playerID)
                return
        }</span>

        // Check if crate is available
        <span class="cov8" title="1">if !crate.IsAvailable </span><span class="cov0" title="0">{
                log.Printf("Player %s attempted to pickup unavailable crate %s", playerID, crateID)
                return
        }</span>

        // Get player state from world
        <span class="cov8" title="1">playerState, exists := h.gameServer.GetWorld().GetPlayer(playerID)
        if !exists </span><span class="cov0" title="0">{
                log.Printf("Player %s not found for weapon pickup", playerID)
                return
        }</span>

        // Check if player is alive
        <span class="cov8" title="1">if !playerState.IsAlive() </span><span class="cov0" title="0">{
                log.Printf("Dead player %s attempted weapon pickup", playerID)
                return
        }</span>

        // Check proximity using physics system
        <span class="cov8" title="1">physics := game.NewPhysics()
        if !physics.CheckPlayerCrateProximity(playerState, crate) </span><span class="cov0" title="0">{
                log.Printf("Player %s out of range for crate %s", playerID, crateID)
                return
        }</span>

        // All validation passed - perform pickup
        // 1. Mark crate as picked up
        <span class="cov8" title="1">success := h.gameServer.GetWeaponCrateManager().PickupCrate(crateID)
        if !success </span><span class="cov0" title="0">{
                log.Printf("Failed to pick up crate %s (race condition)", crateID)
                return
        }</span>

        // 2. Create new weapon for player
        <span class="cov8" title="1">newWeapon, err := game.CreateWeaponByType(crate.WeaponType)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create weapon %s: %v", crate.WeaponType, err)
                // Return crate to available state
                crate.IsAvailable = true
                return
        }</span>

        // 3. Replace player's weapon
        <span class="cov8" title="1">h.gameServer.SetWeaponState(playerID, game.NewWeaponState(newWeapon))

        // 4. Call pickup callback to broadcast to clients
        if h.gameServer.GetWeaponCrateManager().GetCrate(crateID) != nil </span><span class="cov8" title="1">{
                updatedCrate := h.gameServer.GetWeaponCrateManager().GetCrate(crateID)
                h.broadcastWeaponPickup(playerID, crateID, crate.WeaponType, updatedCrate.RespawnTime)

                // 5. Send updated weapon state to picker
                h.sendWeaponState(playerID)
        }</span>

        <span class="cov8" title="1">log.Printf("Player %s picked up %s from crate %s", playerID, crate.WeaponType, crateID)</span>
}

// onWeaponRespawn is called when a weapon crate respawns
func (h *WebSocketHandler) onWeaponRespawn(crate *game.WeaponCrate) <span class="cov8" title="1">{
        h.broadcastWeaponRespawn(crate)
        log.Printf("Weapon crate %s respawned (%s)", crate.ID, crate.WeaponType)
}</span>

// handlePlayerMeleeAttack processes player melee attack messages
func (h *WebSocketHandler) handlePlayerMeleeAttack(playerID string, data any) <span class="cov8" title="1">{
        // Validate data against JSON schema
        if err := h.validator.Validate("player-melee-attack-data", data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Schema validation failed for player:melee_attack from %s: %v", playerID, err)
                return
        }</span>

        // After validation, we can safely type assert
        <span class="cov8" title="1">dataMap := data.(map[string]interface{})
        aimAngle := dataMap["aimAngle"].(float64)

        // Attempt melee attack
        result := h.gameServer.PlayerMeleeAttack(playerID, aimAngle)

        if !result.Success </span><span class="cov0" title="0">{
                log.Printf("Melee attack failed for player %s: %s", playerID, result.Reason)
                return
        }</span>

        // Collect victim IDs
        <span class="cov8" title="1">victimIDs := make([]string, len(result.HitPlayers))
        for i, victim := range result.HitPlayers </span><span class="cov8" title="1">{
                victimIDs[i] = victim.ID
        }</span>

        // Broadcast melee:hit to all players (even if no victims - for swing animation)
        <span class="cov8" title="1">h.broadcastMeleeHit(playerID, victimIDs, result.KnockbackApplied)

        // Process damage events for each victim
        for _, victim := range result.HitPlayers </span><span class="cov8" title="1">{
                // Get weapon to determine damage
                ws := h.gameServer.GetWeaponState(playerID)
                if ws == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">damage := ws.Weapon.Damage

                // Broadcast player:damaged
                h.broadcastPlayerDamaged(playerID, victim.ID, damage, victim.Health)

                // Check if victim died
                if !victim.IsAlive() </span><span class="cov8" title="1">{
                        h.processMeleeKill(playerID, victim.ID)
                }</span>
        }
}

// handlePlayerDodgeRoll processes player dodge roll requests
func (h *WebSocketHandler) handlePlayerDodgeRoll(playerID string) <span class="cov8" title="1">{
        // Get player state from world
        playerState, exists := h.gameServer.GetWorld().GetPlayer(playerID)
        if !exists </span><span class="cov8" title="1">{
                log.Printf("Player %s not found for dodge roll", playerID)
                return
        }</span>

        // Check if player can dodge roll (cooldown, alive, not already rolling)
        <span class="cov8" title="1">if !playerState.CanDodgeRoll() </span><span class="cov0" title="0">{
                log.Printf("Player %s cannot dodge roll (cooldown or dead)", playerID)
                return
        }</span>

        // Determine roll direction based on input
        <span class="cov8" title="1">input := playerState.GetInput()
        direction := game.Vector2{X: 0, Y: 0}

        // Use WASD keys if any are pressed
        if input.Up || input.Down || input.Left || input.Right </span><span class="cov8" title="1">{
                if input.Up </span><span class="cov8" title="1">{
                        direction.Y -= 1
                }</span>
                <span class="cov8" title="1">if input.Down </span><span class="cov0" title="0">{
                        direction.Y += 1
                }</span>
                <span class="cov8" title="1">if input.Left </span><span class="cov0" title="0">{
                        direction.X -= 1
                }</span>
                <span class="cov8" title="1">if input.Right </span><span class="cov8" title="1">{
                        direction.X += 1
                }</span>
        } else<span class="cov8" title="1"> {
                // If stationary, roll in aim direction
                direction.X = 1.0 // Will be rotated by aim angle
                direction.Y = 0.0
        }</span>

        // Normalize direction
        <span class="cov8" title="1">length := math.Sqrt(direction.X*direction.X + direction.Y*direction.Y)
        if length &gt; 0 </span><span class="cov8" title="1">{
                direction.X /= length
                direction.Y /= length
        }</span>

        // If using aim angle and stationary, apply rotation
        <span class="cov8" title="1">if !input.Up &amp;&amp; !input.Down &amp;&amp; !input.Left &amp;&amp; !input.Right </span><span class="cov8" title="1">{
                aimAngle := input.AimAngle
                direction.X = math.Cos(aimAngle)
                direction.Y = math.Sin(aimAngle)
        }</span>

        // Start the dodge roll
        <span class="cov8" title="1">playerState.StartDodgeRoll(direction)

        // Broadcast roll:start to all players in the room
        h.broadcastRollStart(playerID, direction, playerState.GetRollState().RollStartTime)

        log.Printf("Player %s started dodge roll", playerID)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package network

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/kaptinlin/jsonschema"
)

// CompiledSchema wraps a compiled JSON schema
type CompiledSchema struct {
        Name   string
        Schema *jsonschema.Schema
}

// SchemaLoader manages loading and caching of JSON schemas
type SchemaLoader struct {
        schemas map[string]*CompiledSchema
        mu      sync.RWMutex
}

// Singleton instances for schema loaders
var (
        clientToServerLoader     *SchemaLoader
        clientToServerLoaderOnce sync.Once
        serverToClientLoader     *SchemaLoader
        serverToClientLoaderOnce sync.Once
)

// GetClientToServerSchemaLoader returns the singleton client-to-server schema loader
func GetClientToServerSchemaLoader() *SchemaLoader <span class="cov8" title="1">{
        clientToServerLoaderOnce.Do(func() </span><span class="cov8" title="1">{
                paths := []string{
                        "../events-schema/schemas/client-to-server",       // From cmd/server/
                        "../../events-schema/schemas/client-to-server",    // From internal/network/
                        "../../../events-schema/schemas/client-to-server", // From tests
                }

                var err error
                for _, path := range paths </span><span class="cov8" title="1">{
                        clientToServerLoader, err = NewSchemaLoader(path)
                        if err == nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">log.Fatalf("FATAL: Failed to load client-to-server JSON schemas from any path: %v", err)</span>
        })
        <span class="cov8" title="1">return clientToServerLoader</span>
}

// GetServerToClientSchemaLoader returns the singleton server-to-client schema loader
func GetServerToClientSchemaLoader() *SchemaLoader <span class="cov8" title="1">{
        serverToClientLoaderOnce.Do(func() </span><span class="cov8" title="1">{
                paths := []string{
                        "../events-schema/schemas/server-to-client",       // From cmd/server/
                        "../../events-schema/schemas/server-to-client",    // From internal/network/
                        "../../../events-schema/schemas/server-to-client", // From tests
                }

                var err error
                for _, path := range paths </span><span class="cov8" title="1">{
                        serverToClientLoader, err = NewSchemaLoader(path)
                        if err == nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">log.Fatalf("FATAL: Failed to load server-to-client JSON schemas from any path: %v", err)</span>
        })
        <span class="cov8" title="1">return serverToClientLoader</span>
}

// resetSchemaLoaderSingletons resets singleton instances (for testing only)
func resetSchemaLoaderSingletons() <span class="cov8" title="1">{
        clientToServerLoader = nil
        clientToServerLoaderOnce = sync.Once{}
        serverToClientLoader = nil
        serverToClientLoaderOnce = sync.Once{}
}</span>

// NewSchemaLoader creates a new schema loader and loads all schemas from the directory
func NewSchemaLoader(schemaDir string) (*SchemaLoader, error) <span class="cov8" title="1">{
        loader := &amp;SchemaLoader{
                schemas: make(map[string]*CompiledSchema),
        }

        // Check if directory exists
        if _, err := os.Stat(schemaDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("schema directory does not exist: %s", schemaDir)
        }</span>

        // Walk the directory and load all JSON schema files
        <span class="cov8" title="1">err := filepath.Walk(schemaDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories and non-JSON files
                <span class="cov8" title="1">if info.IsDir() || !strings.HasSuffix(path, ".json") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Load the schema file
                <span class="cov8" title="1">if err := loader.loadSchemaFile(path); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load schema %s: %w", path, err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to load schemas: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Loaded %d JSON schemas from %s", len(loader.schemas), schemaDir)
        return loader, nil</span>
}

// loadSchemaFile loads a single JSON schema file
func (l *SchemaLoader) loadSchemaFile(filePath string) error <span class="cov8" title="1">{
        // Read schema file
        schemaBytes, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read schema file: %w", err)
        }</span>

        // Create JSON schema compiler
        <span class="cov8" title="1">compiler := jsonschema.NewCompiler()

        // Compile the schema
        schema, err := compiler.Compile(schemaBytes)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to compile schema: %w", err)
        }</span>

        // Extract schema name from filename (without extension)
        <span class="cov8" title="1">fileName := filepath.Base(filePath)
        schemaName := strings.TrimSuffix(fileName, ".json")

        // Store compiled schema
        l.mu.Lock()
        defer l.mu.Unlock()

        l.schemas[schemaName] = &amp;CompiledSchema{
                Name:   schemaName,
                Schema: schema,
        }

        log.Printf("Loaded schema: %s", schemaName)
        return nil</span>
}

// GetSchema retrieves a compiled schema by name (returns nil if not found)
func (l *SchemaLoader) GetSchema(name string) *CompiledSchema <span class="cov8" title="1">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.schemas[name]
}</span>

// GetSchemaNames returns all loaded schema names
func (l *SchemaLoader) GetSchemaNames() []string <span class="cov8" title="1">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        names := make([]string, 0, len(l.schemas))
        for name := range l.schemas </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package network

import (
        "fmt"
        "log"
)

// SchemaValidator provides validation using pre-loaded JSON schemas
type SchemaValidator struct {
        loader *SchemaLoader
}

// NewSchemaValidator creates a new schema validator
func NewSchemaValidator(loader *SchemaLoader) *SchemaValidator <span class="cov8" title="1">{
        return &amp;SchemaValidator{
                loader: loader,
        }
}</span>

// Validate validates data against a named schema
// Returns nil if validation succeeds, error if validation fails
func (v *SchemaValidator) Validate(schemaName string, data interface{}) error <span class="cov8" title="1">{
        // Check if data is nil
        if data == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: data is nil")
        }</span>

        // Get the schema
        <span class="cov8" title="1">compiledSchema := v.loader.GetSchema(schemaName)
        if compiledSchema == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("schema not found: %s", schemaName)
        }</span>

        // Validate the data using zero-copy validation (direct on interface{})
        <span class="cov8" title="1">result := compiledSchema.Schema.Validate(data)

        // Check if validation passed
        if !result.IsValid() </span><span class="cov8" title="1">{
                // Get all validation errors as a flat list
                errorList := result.ToList()
                if errorList != nil &amp;&amp; len(errorList.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        // Log detailed errors server-side (don't expose to clients)
                        log.Printf("Schema validation failed for %s: %v", schemaName, errorList.Errors)
                        return fmt.Errorf("validation failed for %s: %d errors", schemaName, len(errorList.Errors))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("validation failed for %s", schemaName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateAndLog validates data and logs detailed errors
// Returns true if valid, false if invalid
func (v *SchemaValidator) ValidateAndLog(schemaName string, data interface{}, playerID string) bool <span class="cov8" title="1">{
        err := v.Validate(schemaName, data)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Validation error for player %s: %v", playerID, err)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package network

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/websocket"
        "github.com/mtomcal/stick-rumble-server/internal/game"
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov8" title="1">{
                // MVP: Allow all origins (for localhost development)
                // Production: Restrict to your domain
                return true
        }</span>,
}

// Message represents the standard WebSocket message format
type Message struct {
        Type      string `json:"type"`
        Timestamp int64  `json:"timestamp"`
        Data      any    `json:"data,omitempty"`
}

// WebSocketHandler manages WebSocket connections and room management
type WebSocketHandler struct {
        roomManager       *game.RoomManager
        gameServer        *game.GameServer
        timerInterval     time.Duration // Interval for match timer broadcasts (default 1s)
        validator         *SchemaValidator
        outgoingValidator *SchemaValidator
}

// NewWebSocketHandler creates a new WebSocket handler with room management
func NewWebSocketHandler() *WebSocketHandler <span class="cov8" title="1">{
        return NewWebSocketHandlerWithConfig(1 * time.Second)
}</span>

// NewWebSocketHandlerWithConfig creates a WebSocket handler with custom timer interval
func NewWebSocketHandlerWithConfig(timerInterval time.Duration) *WebSocketHandler <span class="cov8" title="1">{
        // Use singleton schema loaders to avoid loading schemas multiple times
        // This prevents race conditions and reduces memory usage in tests
        schemaLoader := GetClientToServerSchemaLoader()
        outgoingSchemaLoader := GetServerToClientSchemaLoader()

        handler := &amp;WebSocketHandler{
                roomManager:       game.NewRoomManager(),
                timerInterval:     timerInterval,
                validator:         NewSchemaValidator(schemaLoader),
                outgoingValidator: NewSchemaValidator(outgoingSchemaLoader),
        }

        // Create game server with broadcast function
        handler.gameServer = game.NewGameServer(handler.broadcastPlayerStates)

        // Register callback for reload completion to notify clients
        handler.gameServer.SetOnReloadComplete(handler.onReloadComplete)

        // Register callback for hit events
        handler.gameServer.SetOnHit(handler.onHit)

        // Register callback for respawn events
        handler.gameServer.SetOnRespawn(handler.onRespawn)

        // Register callback for weapon respawn events
        handler.gameServer.SetOnWeaponRespawn(handler.onWeaponRespawn)

        // Register callback for dodge roll end events
        handler.gameServer.SetOnRollEnd(handler.broadcastRollEnd)

        return handler
}</span>

// matchTimerLoop broadcasts match timer updates at the configured interval
func (h *WebSocketHandler) matchTimerLoop(ctx context.Context) <span class="cov8" title="1">{
        ticker := time.NewTicker(h.timerInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("Match timer loop stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        h.broadcastMatchTimers()</span>
                }
        }
}

// Global handler instance for the legacy function to share room state
// Uses lazy initialization to prevent schema loading at package init time
var (
        globalHandler     *WebSocketHandler
        globalHandlerOnce sync.Once
)

// getGlobalHandler returns the singleton global handler instance
func getGlobalHandler() *WebSocketHandler <span class="cov8" title="1">{
        globalHandlerOnce.Do(func() </span><span class="cov8" title="1">{
                globalHandler = NewWebSocketHandler()
        }</span>)
        <span class="cov8" title="1">return globalHandler</span>
}

// resetGlobalHandler resets the global handler (for testing only)
func resetGlobalHandler() <span class="cov8" title="1">{
        globalHandler = nil
        globalHandlerOnce = sync.Once{}
}</span>

// Start starts the game server tick loop and match timer broadcasts
func (h *WebSocketHandler) Start(ctx context.Context) <span class="cov8" title="1">{
        h.gameServer.Start(ctx)
        go h.matchTimerLoop(ctx)
}</span>

// Stop stops the game server
func (h *WebSocketHandler) Stop() <span class="cov8" title="1">{
        h.gameServer.Stop()
}</span>

// StartGlobalHandler starts the global handler's game server
func StartGlobalHandler(ctx context.Context) <span class="cov8" title="1">{
        getGlobalHandler().Start(ctx)
}</span>

// StopGlobalHandler stops the global handler's game server
func StopGlobalHandler() <span class="cov8" title="1">{
        getGlobalHandler().Stop()
}</span>

// validateOutgoingMessage validates outgoing serverclient messages against JSON schemas
// Only validates when ENABLE_SCHEMA_VALIDATION environment variable is set to "true"
// Returns nil if validation passes or is disabled, error if validation fails
func (h *WebSocketHandler) validateOutgoingMessage(messageType string, data interface{}) (err error) <span class="cov8" title="1">{
        // Check if schema validation is enabled (development mode only)
        if os.Getenv("ENABLE_SCHEMA_VALIDATION") != "true" </span><span class="cov8" title="1">{
                return nil // Skip validation in production
        }</span>

        // Recover from any panics in the validator library (e.g., NaN values)
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Schema validator panicked for %s: %v", messageType, r)
                        err = fmt.Errorf("validator panic: %v", r)
                }</span>
        }()

        // Map message type to schema name (message:type_subtype  message-type-subtype-data)
        // Server-to-client schemas follow the pattern: {message-type}-data.json
        // Replace colons and underscores with hyphens to match filename convention
        <span class="cov8" title="1">schemaName := strings.ReplaceAll(messageType, ":", "-")
        schemaName = strings.ReplaceAll(schemaName, "_", "-")
        schemaName = schemaName + "-data"

        // Validate the data against the schema
        err = h.outgoingValidator.Validate(schemaName, data)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Outgoing message validation failed for %s: %v", messageType, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleWebSocket upgrades HTTP connection to WebSocket and manages message loop
func (h *WebSocketHandler) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Upgrade HTTP connection to WebSocket
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("WebSocket upgrade failed:", err)
                return
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        // Create player with unique ID
        playerID := uuid.New().String()
        // Buffer size 256: Allows burst messages while preventing memory exhaustion.
        // If buffer fills (slow/unresponsive client), messages are dropped with log warning.
        sendChan := make(chan []byte, 256)
        player := &amp;game.Player{
                ID:       playerID,
                SendChan: sendChan,
        }

        log.Printf("Client connected: %s", playerID)

        // Add player to room manager
        room := h.roomManager.AddPlayer(player)

        // Add player to game server
        h.gameServer.AddPlayer(playerID)

        // If player joined a room, send initial weapon spawn state to all players
        if room != nil </span><span class="cov8" title="1">{
                // Send weapon spawns to all players in the newly created room
                for _, p := range room.GetPlayers() </span><span class="cov8" title="1">{
                        h.sendWeaponSpawns(p.ID)
                }</span>
        }

        // Start goroutine to send messages to client
        <span class="cov8" title="1">done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                defer close(done)
                for msg := range sendChan </span><span class="cov8" title="1">{
                        if err := conn.WriteMessage(websocket.TextMessage, msg); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Write error for %s: %v", playerID, err)
                                return
                        }</span>
                }
        }()

        // Message handling loop
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // Read message from client
                _, messageBytes, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span> else<span class="cov8" title="1"> {
                                log.Printf("Client disconnected: %s", playerID)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                // Parse JSON message
                <span class="cov8" title="1">var msg Message
                if err := json.Unmarshal(messageBytes, &amp;msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse message: %v", err)
                        continue</span>
                }

                <span class="cov8" title="1">log.Printf("Received from %s: type=%s, timestamp=%d", playerID, msg.Type, msg.Timestamp)

                // Handle different message types
                switch msg.Type </span>{
                case "input:state":<span class="cov8" title="1">
                        // Handle player input
                        h.handleInputState(playerID, msg.Data)</span>

                case "player:shoot":<span class="cov8" title="1">
                        // Handle player shooting
                        h.handlePlayerShoot(playerID, msg.Data)</span>

                case "player:reload":<span class="cov8" title="1">
                        // Handle player reloading
                        h.handlePlayerReload(playerID)</span>

                case "weapon:pickup_attempt":<span class="cov8" title="1">
                        // Handle weapon pickup
                        h.handleWeaponPickup(playerID, msg.Data)</span>

                case "player:dodge_roll":<span class="cov0" title="0">
                        // Handle player dodge roll
                        h.handlePlayerDodgeRoll(playerID)</span>

                case "player:melee_attack":<span class="cov0" title="0">
                        // Handle player melee attack
                        h.handlePlayerMeleeAttack(playerID, msg.Data)</span>

                default:<span class="cov8" title="1">
                        // Broadcast other messages to room (for backward compatibility with tests)
                        room := h.roomManager.GetRoomByPlayerID(playerID)
                        if room != nil </span><span class="cov8" title="1">{
                                room.Broadcast(messageBytes, playerID)
                        }</span>
                }
        }

        // Clean up on disconnect
        <span class="cov8" title="1">h.roomManager.RemovePlayer(playerID)
        h.gameServer.RemovePlayer(playerID)
        close(sendChan)
        &lt;-done // Wait for send goroutine to finish

        log.Printf("Connection closed: %s", playerID)</span>
}

// HandleWebSocket is the legacy function for backward compatibility
// It uses a shared global handler to ensure all connections share the same room state
func HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        getGlobalHandler().HandleWebSocket(w, r)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
