<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>2</storyId>
    <title>Initialize Backend Golang Server</title>
    <status>drafted</status>
    <generatedAt>2025-11-25</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-2-initialize-backend-golang-server.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>the backend Go server project initialized with core dependencies</iWant>
    <soThat>I can build the multiplayer game server with WebSocket support</soThat>
    <tasks>
      - Initialize Go project structure (create stick-rumble-server/, run go mod init, create cmd/server/ and internal/ directories)
      - Install core dependencies (gorilla/websocket@v1.5.3, go-pkgz/auth/v2, lib/pq, redis/go-redis/v9, testify)
      - Implement basic HTTP server (cmd/server/main.go with /health endpoint, PORT environment variable)
      - Create WebSocket handler stub (internal/network/websocket_handler.go returning "not yet implemented")
      - Verify server functionality (go run, curl /health, go test, go build)
      - Create supporting files (.gitignore, README.md documenting setup)
      - Write unit tests (main_test.go with health endpoint test using testify)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Go 1.23+ module created with go mod init github.com/yourusername/stick-rumble-server
    2. Core dependencies installed: gorilla/websocket@v1.5.3, go-pkgz/auth/v2, lib/pq, redis/go-redis/v9, testify
    3. Project structure: cmd/server/main.go, internal/{game,network,auth,db,config}/
    4. go run cmd/server/main.go starts HTTP server on port 8080
    5. curl http://localhost:8080/health returns "OK" with 200 status
    6. go test ./... runs successfully
    7. go build -o server cmd/server/main.go creates binary
    8. All dependencies listed in go.mod with versions
    9. Server logs "Server starting on port 8080" to stdout
    10. No compilation errors or warnings
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epic-1-tech-spec.md</path>
        <title>Epic 1: Foundation & Project Setup - Technical Specification</title>
        <section>Story 1.2: Initialize Backend Golang Server</section>
        <snippet>Provides complete Go project setup commands, directory structure, initial implementation for cmd/server/main.go and internal/network/websocket_handler.go stub, .gitignore template, and validation tests using testify. Includes troubleshooting for common issues (port conflicts, go get failures, module path errors).</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Stick Rumble - Epic Breakdown</title>
        <section>Epic 1, Story 1.2</section>
        <snippet>Details backend server initialization requirements: Go 1.23+ module, core dependencies (websocket, auth, db), project structure matching architecture doc, basic HTTP server with /health endpoint, testing with go test. Notes parallel development possible with Story 1.1.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/1-1-initialize-frontend-project-with-phaser-react.md</path>
        <title>Story 1.1: Initialize Frontend Project (Completed)</title>
        <section>Dev Agent Record, Learnings</section>
        <snippet>Completed frontend initialization with Phaser 3.90, React 19.2, TypeScript 5.9, Vite 7.2. Established patterns: separate project directories (stick-rumble-client/ and stick-rumble-server/ as siblings), environment variable configuration, minimal setup tests, comprehensive README documentation. All review findings resolved.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>stick-rumble-client/package.json</path>
        <kind>dependency-manifest</kind>
        <symbol>N/A</symbol>
        <lines>1-40</lines>
        <reason>Reference for frontend dependencies. Backend will use similar structure: Go modules instead of npm, testify for testing assertions, similar documentation approach.</reason>
      </artifact>
      <artifact>
        <path>stick-rumble-client/</path>
        <kind>project-directory</kind>
        <symbol>Frontend Project Root</symbol>
        <lines>N/A</lines>
        <reason>Sibling directory to stick-rumble-server/. Backend should follow same organizational pattern: separate project with own dependency management, independent build process, clear README.</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="node">
        <package name="phaser" version="^3.90.0" reason="Frontend game engine (reference only, not used in backend)" />
        <package name="react" version="^19.2.0" reason="Frontend UI framework (reference only)" />
        <package name="vitest" version="^4.0.13" reason="Frontend testing (backend uses Go testing + testify)" />
      </ecosystem>
      <ecosystem name="go">
        <package name="github.com/gorilla/websocket" version="v1.5.3" reason="WebSocket protocol implementation for real-time client-server communication (Story 1.3 will use)" />
        <package name="github.com/go-pkgz/auth/v2" version="v2.x.x" reason="OAuth authentication library (Epic 6: Player Identity)" />
        <package name="github.com/lib/pq" version="latest" reason="PostgreSQL driver (Epic 6: persistent player data)" />
        <package name="github.com/redis/go-redis/v9" version="v9.x.x" reason="Redis client (Epic 5: matchmaking queues)" />
        <package name="github.com/stretchr/testify" version="v1.x.x" reason="Testing assertions and mocks" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    - Use Go standard library net/http for HTTP server (no Gin/Echo frameworks for MVP - ADR-004: Minimal Dependencies)
    - internal/ directory structure prevents external imports (Go best practice for encapsulation)
    - Package naming: lowercase, single word (e.g., "package network" not "package Network")
    - File naming: snake_case (e.g., "websocket_handler.go" not "websocketHandler.go")
    - Error handling: check all errors, log appropriately using log package
    - Environment-based configuration: PORT environment variable with default 8080
    - Health check endpoint required at /health for monitoring and deployment readiness
    - Create stub for /ws WebSocket endpoint (Story 1.3 will implement full functionality)
    - Backend project in stick-rumble-server/ as sibling to stick-rumble-client/ (not subdirectory)
    - Go 1.23+ required (verify with go version before starting)
    - Dependencies must be pinned to specific versions in go.mod
    - Testing framework: Go testing + testify assertions (no third-party test runners)
    - Test location: _test.go files colocated with source (e.g., cmd/server/main_test.go)
    - Coverage goal: 70%+ for server logic (minimal tests acceptable for initialization story)
  </constraints>

  <interfaces>
    <interface>
      <name>/health HTTP Endpoint</name>
      <kind>REST</kind>
      <signature>GET /health → 200 OK, body: "OK"</signature>
      <path>cmd/server/main.go</path>
      <notes>Required for deployment health checks, load balancer probes, and monitoring systems</notes>
    </interface>
    <interface>
      <name>/ws WebSocket Endpoint (Stub)</name>
      <kind>WebSocket</kind>
      <signature>GET /ws → 501 Not Implemented, body: "WebSocket handler coming in Story 1.3"</signature>
      <path>internal/network/websocket_handler.go</path>
      <notes>Placeholder for Story 1.3 WebSocket implementation. Should log endpoint hits but not upgrade connections yet.</notes>
    </interface>
    <interface>
      <name>HandleWebSocket Function</name>
      <kind>Go Function</kind>
      <signature>func HandleWebSocket(w http.ResponseWriter, r *http.Request)</signature>
      <path>internal/network/websocket_handler.go</path>
      <notes>Stub implementation returns HTTP 501 Not Implemented. Story 1.3 will implement WebSocket upgrade using gorilla/websocket.</notes>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing Framework: Go testing + testify assertions. Test files colocated with source using _test.go suffix (e.g., main_test.go). Use httptest.NewRequest and httptest.NewRecorder for HTTP endpoint testing. Coverage goal: 70%+ for server logic. For this initialization story, minimal tests acceptable: verify health endpoint returns 200 OK, verify go test ./... runs without errors, verify binary builds successfully.
    </standards>
    <locations>
      - cmd/server/*_test.go (tests for main.go and server initialization)
      - internal/network/*_test.go (tests for WebSocket handler stub)
      - Run tests with: go test ./...
      - Check coverage with: go test -cover ./...
    </locations>
    <ideas>
      - AC#5: TestHealthEndpoint - verify /health returns HTTP 200 with body "OK" using httptest
      - AC#6: Test that go test ./... runs without errors (meta-test or manual verification)
      - AC#7: Test that go build creates binary (integration test or manual verification)
      - AC#9: Test server logs "Server starting on port 8080" (capture log output)
      - AC#4: TestWebSocketStub - verify /ws returns HTTP 501 with "not yet implemented" message
      - Future: TestPortConfiguration - verify PORT environment variable overrides default
    </ideas>
  </tests>
</story-context>
